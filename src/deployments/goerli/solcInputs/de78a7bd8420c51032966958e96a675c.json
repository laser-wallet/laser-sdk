{
  "language": "Solidity",
  "sources": {
    "contracts/access/Access.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity 0.8.15;\n\ncontract Access {\n    error Access__notAllowed();\n\n    modifier access() {\n        if (msg.sender != address(this)) revert Access__notAllowed();\n\n        _;\n    }\n}\n"
    },
    "contracts/state/LaserState.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity 0.8.15;\n\nimport \"../access/Access.sol\";\nimport \"../common/Utils.sol\";\nimport \"../interfaces/IERC165.sol\";\nimport \"../interfaces/ILaserMasterGuard.sol\";\nimport \"../interfaces/ILaserState.sol\";\nimport \"../interfaces/ILaserRegistry.sol\";\n\n/////\n///////// @todo Add 'removeModule', should be the signature of the owner + guardian\n////////        or owner + recovery owner.\n/////\ncontract LaserState is ILaserState, Access {\n    address internal constant POINTER = address(0x1); // Pointer for the link list.\n\n    /*//////////////////////////////////////////////////////////////\n                         Laser Wallet storage\n    //////////////////////////////////////////////////////////////*/\n\n    address public singleton; // Base contract.\n\n    address public owner; // Owner of the wallet.\n\n    address public laserMasterGuard; // Parent module for guard sub modules.\n\n    address public laserRegistry; // Registry that keeps track of authorized modules (Laser and Guards).\n\n    bool public isLocked; // If the wallet is locked, only certain operations can unlock it.\n\n    uint256 public nonce; // Anti-replay number for signed transactions.\n\n    mapping(address => address) internal laserModules; // Mapping of authorized Laser modules.\n\n    /**\n     * @notice Restricted, can only be called by the wallet 'address(this)' or module.\n     *\n     * @param newOwner  Address of the new owner.\n     */\n    function changeOwner(address newOwner) external access {\n        owner = newOwner;\n    }\n\n    /**\n     * @notice Restricted, can only be called by the wallet 'address(this)' or module.\n     *\n     * @param newModule Address of a new authorized Laser module.\n     */\n    function addLaserModule(address newModule) external access {\n        require(ILaserRegistry(laserRegistry).isModule(newModule), \"Invalid new module\");\n        laserModules[newModule] = laserModules[POINTER];\n        laserModules[POINTER] = newModule;\n    }\n\n    function upgradeSingleton(address _singleton) external access {\n        //@todo Change require for custom errrors.\n        require(_singleton != address(this), \"Invalid singleton\");\n        require(ILaserRegistry(laserRegistry).isSingleton(_singleton), \"Invalid master copy\");\n        singleton = _singleton;\n    }\n\n    function activateWallet(\n        address _owner,\n        address smartSocialRecoveryModule,\n        address _laserMasterGuard,\n        address laserVault,\n        address _laserRegistry,\n        bytes calldata smartSocialRecoveryInitData\n    ) internal {\n        // If owner is not address 0, the wallet was already initialized.\n        if (owner != address(0)) revert LaserState__initOwner__walletInitialized();\n\n        if (_owner.code.length != 0 || _owner == address(0)) revert LaserState__initOwner__invalidAddress();\n\n        // We set the owner.\n        owner = _owner;\n\n        // check that the module is accepted.\n        laserMasterGuard = _laserMasterGuard;\n        laserRegistry = _laserRegistry;\n\n        require(ILaserRegistry(laserRegistry).isModule(smartSocialRecoveryModule), \"Module not authorized\");\n        bool success = Utils.call(smartSocialRecoveryModule, 0, smartSocialRecoveryInitData, gasleft());\n        require(success);\n        laserModules[smartSocialRecoveryModule] = POINTER;\n\n        // We add the guard module.\n        ILaserMasterGuard(_laserMasterGuard).addGuardModule(laserVault);\n    }\n}\n"
    },
    "contracts/common/Utils.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity 0.8.15;\n\nimport \"../interfaces/IEIP1271.sol\";\n\n/**\n * @title Utils - Helper functions for Laser wallet and modules.\n */\nlibrary Utils {\n    /*//////////////////////////////////////////////////////////////\n                            Errors\n    //////////////////////////////////////////////////////////////*/\n\n    error Utils__returnSigner__invalidSignature();\n\n    error Utils__returnSigner__invalidContractSignature();\n\n    /**\n     * @param signedHash  The hash that was signed.\n     * @param signatures  Result of signing the has.\n     * @param pos         Position of the signer.\n     *\n     * @return signer      Address that signed the hash.\n     */\n    function returnSigner(\n        bytes32 signedHash,\n        bytes memory signatures,\n        uint256 pos\n    ) internal view returns (address signer) {\n        bytes32 r;\n        bytes32 s;\n        uint8 v;\n        (r, s, v) = splitSigs(signatures, pos);\n\n        if (v == 0) {\n            // If v is 0, then it is a contract signature.\n            // The address of the contract is encoded into r.\n            signer = address(uint160(uint256(r)));\n\n            // The signature(s) of the EOA's that control the target contract.\n            bytes memory contractSignature;\n\n            assembly {\n                contractSignature := add(add(signatures, s), 0x20)\n            }\n\n            if (IEIP1271(signer).isValidSignature(signedHash, contractSignature) != 0x1626ba7e) {\n                revert Utils__returnSigner__invalidContractSignature();\n            }\n        } else if (v > 30) {\n            signer = ecrecover(\n                keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", signedHash)),\n                v - 4,\n                r,\n                s\n            );\n        } else {\n            signer = ecrecover(signedHash, v, r, s);\n        }\n\n        if (signer == address(0)) revert Utils__returnSigner__invalidSignature();\n    }\n\n    /**\n     * @dev Returns the r, s and v values of the signature.\n     *\n     * @param pos Which signature to read.\n     */\n    function splitSigs(bytes memory signatures, uint256 pos)\n        internal\n        pure\n        returns (\n            bytes32 r,\n            bytes32 s,\n            uint8 v\n        )\n    {\n        assembly {\n            let sigPos := mul(0x41, pos)\n            r := mload(add(signatures, add(sigPos, 0x20)))\n            s := mload(add(signatures, add(sigPos, 0x40)))\n            v := byte(0, mload(add(signatures, add(sigPos, 0x60))))\n        }\n    }\n\n    /**\n     * @dev Calls a target address, sends value and / or data payload.\n     *\n     * @param to     Destination address.\n     * @param value  Amount in WEI to transfer.\n     * @param callData   Data payload for the transaction.\n     */\n    function call(\n        address to,\n        uint256 value,\n        bytes memory callData,\n        uint256 txGas\n    ) internal returns (bool success) {\n        assembly {\n            success := call(txGas, to, value, add(callData, 0x20), mload(callData), 0, 0)\n        }\n    }\n\n    /**\n     * @dev Calculates the gas price for the transaction.\n     */\n    function calculateGasPrice(uint256 maxFeePerGas, uint256 maxPriorityFeePerGas) internal view returns (uint256) {\n        if (maxFeePerGas == maxPriorityFeePerGas) {\n            // Legacy mode (pre-EIP1559)\n            return min(maxFeePerGas, tx.gasprice);\n        }\n\n        // EIP-1559\n        // priority_fee_per_gas = min(transaction.max_priority_fee_per_gas, transaction.max_fee_per_gas - block.base_fee_per_gas)\n        // effective_gas_price = priority_fee_per_gas + block.base_fee_per_gas\n        uint256 priorityFeePerGas = min(maxPriorityFeePerGas, maxFeePerGas - block.basefee);\n\n        // effective_gas_price\n        return priorityFeePerGas + block.basefee;\n    }\n\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n}\n"
    },
    "contracts/interfaces/IERC165.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.15;\n\n/**\n * @title IERC165\n * @notice Support of ERC165.\n */\ninterface IERC165 {\n    /**\n     * @notice Query if a contract implements an interface\n     * @param interfaceID The interface identifier, as specified in ERC-165\n     * @dev Interface identification is specified in ERC-165. This function\n     * uses less than 30,000 gas.\n     * @return `true` if the contract implements `interfaceID` and\n     * interfaceID` is not 0xffffffff, `false` otherwise\n     */\n    function supportsInterface(bytes4 interfaceID) external view returns (bool);\n}\n"
    },
    "contracts/interfaces/ILaserMasterGuard.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.15;\n\n/**\n * @title  ILaserMasterGuard\n *\n * @author Rodrigo Herrera I.\n *\n * @notice Parent guard module that calls child Laser guards.\n *\n * @dev    This interface has all events, errors, and external function for LaserMasterGuard.\n */\ninterface ILaserMasterGuard {\n    // addGuardModule() custom errors.\n    error LaserMasterGuard__addGuardModule__unauthorizedModule();\n    error LaserMasterGuard__addGuardModule__overflow();\n\n    // removeGuardModule custom errors.\n    error LaserMasterGuard__removeGuardModule__incorrectModule();\n    error LaserMasterGuard__removeGuardModule__incorrectPrevModule();\n\n    /**\n     * @notice Adds a new guard module.\n     *         wallet is 'msg.sender'.\n     *\n     * @param module The address of the new module. It needs to be authorized in LaserRegistry.\n     */\n    function addGuardModule(address module) external;\n\n    /**\n     * @notice Removes a guard module.\n     * wallet is 'msg.sender'.\n     *\n     * @param prevModule    The address of the previous module on the linked list.\n     * @param module        The address of the module to remove.\n     */\n    function removeGuardModule(\n        address prevModule,\n        address module,\n        bytes calldata guardianSignature\n    ) external;\n\n    /**\n     * @notice Verifies a Laser transaction.\n     *         It calls all guard sub-modules with the 'verifyTransaction api'.\n     *         Each sub-module implements its own logic. But the main purpose is to\n     *         provide extra transaction security.\n     *\n     * @param wallet                The address of the wallet: should be 'msg.sender'.\n     * @param to                    Destination address.\n     * @param value                 Amount in WEI to transfer.\n     * @param callData              Data payload for the transaction.\n     * @param nonce                 Anti-replay number.\n     * @param maxFeePerGas          Maximum WEI the owner is willing to pay per unit of gas.\n     * @param maxPriorityFeePerGas  Miner's tip.\n     * @param gasLimit              Maximum amount of gas the owner is willing to use for this transaction.\n     * @param signatures            The signature(s) of the hash of this transaction.\n     */\n    function verifyTransaction(\n        address wallet,\n        address to,\n        uint256 value,\n        bytes calldata callData,\n        uint256 nonce,\n        uint256 maxFeePerGas,\n        uint256 maxPriorityFeePerGas,\n        uint256 gasLimit,\n        bytes memory signatures\n    ) external;\n\n    /**\n     * @param wallet The requested address.\n     *\n     * @return The guard modules that belong to the requested address.\n     */\n    function getGuardModules(address wallet) external view returns (address[] memory);\n}\n"
    },
    "contracts/interfaces/ILaserState.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity 0.8.15;\n\ninterface ILaserState {\n    ///@dev upgradeSingleton() custom error.\n    error LaserState__upgradeSingleton__notLaser();\n\n    ///@dev initOwner() custom errors.\n    error LaserState__initOwner__walletInitialized();\n    error LaserState__initOwner__invalidAddress();\n\n    function singleton() external view returns (address);\n\n    function owner() external view returns (address);\n\n    function laserMasterGuard() external view returns (address);\n\n    function laserRegistry() external view returns (address);\n\n    function isLocked() external view returns (bool);\n\n    function nonce() external view returns (uint256);\n\n    ///@notice Restricted, can only be called by the wallet or module.\n    function changeOwner(address newOwner) external;\n\n    ///@notice Restricted, can only be called by the wallet.\n    function addLaserModule(address newModule) external;\n}\n"
    },
    "contracts/interfaces/ILaserRegistry.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity 0.8.15;\n\ninterface ILaserRegistry {\n    function isSingleton(address singleton) external view returns (bool);\n\n    function isModule(address module) external view returns (bool);\n}\n"
    },
    "contracts/interfaces/IEIP1271.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity 0.8.15;\n\n/**\n * @title IEIP1271\n * @notice Interface to call external contracts to validate signature.\n */\ninterface IEIP1271 {\n    /**\n     * @dev Implementation of EIP 1271: https://eips.ethereum.org/EIPS/eip-1271.\n     * @param hash Hash of a message signed on behalf of address(this).\n     * @param signature Signature byte array associated with _msgHash.\n     * @return Magic value  or reverts with an error message.\n     */\n    function isValidSignature(bytes32 hash, bytes memory signature) external view returns (bytes4);\n}\n"
    },
    "contracts/modules/laser-guard/LaserMasterGuard.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity 0.8.15;\n\nimport \"../../common/Utils.sol\";\nimport \"../../interfaces/ILaserGuard.sol\";\nimport \"../../interfaces/ILaserMasterGuard.sol\";\nimport \"../../interfaces/ILaserModuleSSR.sol\";\nimport \"../../interfaces/ILaserRegistry.sol\";\n\n/**\n * @title LaserMasterGuard\n *\n * @author Rodrigo Herrera I.\n *\n * @notice Parent guard module that calls child Laser guards.\n */\ncontract LaserMasterGuard is ILaserMasterGuard {\n    /*//////////////////////////////////////////////////////////////\n                            Constans\n    //////////////////////////////////////////////////////////////*/\n\n    address private constant POINTER = address(0x1);\n\n    address public immutable LASER_REGISTRY;\n\n    address public immutable LASER_SMART_SOCIAL_RECOVERY;\n\n    /*//////////////////////////////////////////////////////////////\n                        LaserMasterGuard's storage\n    //////////////////////////////////////////////////////////////*/\n\n    mapping(address => uint256) internal guardModulesCount;\n\n    mapping(address => mapping(address => address)) internal guardModules;\n\n    /**\n     * @param laserRegistry         Address of LaserRegistry: contract that contains the addresses\n     *                              of authorized modules.\n     * @param smartSocialRecovery   Address of Laser smart social recovery module.\n     */\n    constructor(address laserRegistry, address smartSocialRecovery) {\n        LASER_REGISTRY = laserRegistry;\n        //@todo Check that the smart social recovery is registred in LaserRegistry.\n        LASER_SMART_SOCIAL_RECOVERY = smartSocialRecovery;\n    }\n\n    /**\n     * @notice Adds a new guard module.\n     *         wallet is 'msg.sender'.\n     *\n     * @param module The address of the new module. It needs to be authorized in LaserRegistry.\n     */\n    function addGuardModule(address module) external {\n        address wallet = msg.sender;\n\n        // @todo undo this (make the deployments - approvals automatic on deploy).\n        // if (!ILaserRegistry(LASER_REGISTRY).isModule(module)) {\n        //     revert LaserMasterGuard__addGuardModule__unauthorizedModule();\n        // }\n\n        if (guardModulesCount[wallet] == 0) {\n            initGuardModule(wallet, module);\n        } else {\n            guardModules[wallet][module] = guardModules[wallet][POINTER];\n            guardModules[wallet][POINTER] = module;\n        }\n\n        unchecked {\n            ++guardModulesCount[wallet];\n        }\n\n        // We can only have a maximum amount of 3 guard modules with low amount of gas usage per transaction.\n        // This rule is to avoid a self-inflicted DDoS attack.\n        if (guardModulesCount[wallet] == 4) revert LaserMasterGuard__addGuardModule__overflow();\n    }\n\n    /**\n     * @notice Removes a guard module.\n     * wallet is 'msg.sender'.\n     *\n     * @param prevModule    The address of the previous module on the linked list.\n     * @param module        The address of the module to remove.\n     */\n    function removeGuardModule(\n        address prevModule,\n        address module,\n        bytes calldata guardianSignature\n    ) external {\n        address wallet = msg.sender;\n\n        bytes32 signedHash = keccak256(abi.encodePacked(module, block.chainid));\n\n        address signer = Utils.returnSigner(signedHash, guardianSignature, 0);\n\n        require(ILaserModuleSSR(LASER_SMART_SOCIAL_RECOVERY).isGuardian(wallet, signer), \"Invalid guardian signature\");\n\n        if (guardModules[wallet][module] == address(0)) {\n            revert LaserMasterGuard__removeGuardModule__incorrectModule();\n        }\n\n        if (module == POINTER) {\n            revert LaserMasterGuard__removeGuardModule__incorrectModule();\n        }\n\n        if (guardModules[wallet][prevModule] != module) {\n            revert LaserMasterGuard__removeGuardModule__incorrectPrevModule();\n        }\n\n        guardModules[wallet][prevModule] = guardModules[wallet][module];\n        guardModules[wallet][module] = address(0);\n\n        guardModulesCount[wallet]--;\n    }\n\n    /**\n     * @notice Verifies a Laser transaction.\n     *         It calls all guard sub-modules with the 'verifyTransaction api'.\n     *         Each sub-module implements its own logic. But the main purpose is to\n     *         provide extra transaction security.\n     *\n     * @param wallet                The address of the wallet: should be 'msg.sender'.\n     * @param to                    Destination address.\n     * @param value                 Amount in WEI to transfer.\n     * @param callData              Data payload for the transaction.\n     * @param nonce                 Anti-replay number.\n     * @param maxFeePerGas          Maximum WEI the owner is willing to pay per unit of gas.\n     * @param maxPriorityFeePerGas  Miner's tip.\n     * @param gasLimit              Maximum amount of gas the owner is willing to use for this transaction.\n     * @param signatures            The signature(s) of the hash of this transaction.\n     */\n    function verifyTransaction(\n        address wallet,\n        address to,\n        uint256 value,\n        bytes calldata callData,\n        uint256 nonce,\n        uint256 maxFeePerGas,\n        uint256 maxPriorityFeePerGas,\n        uint256 gasLimit,\n        bytes memory signatures\n    ) external {\n        uint256 nGuards = guardModulesCount[wallet];\n\n        if (nGuards > 0) {\n            address currentGuardModule = guardModules[wallet][POINTER];\n\n            if (nGuards == 1) {\n                // If there is only 1 guard module, there is no need to loop.\n                ILaserGuard(currentGuardModule).verifyTransaction(\n                    wallet,\n                    to,\n                    value,\n                    callData,\n                    nonce,\n                    maxFeePerGas,\n                    maxPriorityFeePerGas,\n                    gasLimit,\n                    signatures\n                );\n            } else {\n                // Guard modules are capped at max 3, and each one is verified that the gas usage\n                // is in bounds. Therefore there is no risk of DDoS (using so much gas that the transaction reverts).\n                while (currentGuardModule != POINTER) {\n                    ILaserGuard(currentGuardModule).verifyTransaction(\n                        wallet,\n                        to,\n                        value,\n                        callData,\n                        nonce,\n                        maxFeePerGas,\n                        maxPriorityFeePerGas,\n                        gasLimit,\n                        signatures\n                    );\n\n                    currentGuardModule = guardModules[wallet][currentGuardModule];\n                }\n            }\n        }\n    }\n\n    /**\n     * @param wallet The requested address.\n     *\n     * @return The guard modules that belong to the requested address.\n     */\n    function getGuardModules(address wallet) public view returns (address[] memory) {\n        address[] memory guardModulesArray = new address[](guardModulesCount[wallet]);\n        address currentGuardModule = guardModules[wallet][POINTER];\n\n        uint256 index;\n\n        while (currentGuardModule != POINTER) {\n            guardModulesArray[index] = currentGuardModule;\n            currentGuardModule = guardModules[wallet][currentGuardModule];\n            unchecked {\n                ++index;\n            }\n        }\n        return guardModulesArray;\n    }\n\n    /**\n     * @notice Inits the guard modules for a specific wallet.\n     *\n     * @param  wallet  Address of the wallet to init the guard module.\n     * @param  module  Address of the module to init.\n     */\n    function initGuardModule(address wallet, address module) internal {\n        guardModules[wallet][POINTER] = module;\n        guardModules[wallet][module] = POINTER;\n    }\n}\n"
    },
    "contracts/interfaces/ILaserGuard.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.15;\n\n/**\n * @title  ILaserGuard\n *\n * @notice Common api interface for all Guard modules (parent and child).\n */\ninterface ILaserGuard {\n    /**\n     * @notice Verifies a Laser transaction.\n     *         It calls all guard sub-modules with the 'verifyTransaction api'.\n     *         Each sub-module implements its own logic. But the main purpose is to\n     *         provide extra transaction security.\n     *\n     * @param wallet The address of the wallet: should be 'msg.sender'.\n     * @param to                    Destination address.\n     * @param value                 Amount in WEI to transfer.\n     * @param callData              Data payload for the transaction.\n     * @param nonce                 Anti-replay number.\n     * @param maxFeePerGas          Maximum WEI the owner is willing to pay per unit of gas.\n     * @param maxPriorityFeePerGas  Miner's tip.\n     * @param gasLimit              Maximum amount of gas the owner is willing to use for this transaction.\n     * @param signatures            The signature(s) of the hash of this transaction.\n     */\n    function verifyTransaction(\n        address wallet,\n        address to,\n        uint256 value,\n        bytes calldata callData,\n        uint256 nonce,\n        uint256 maxFeePerGas,\n        uint256 maxPriorityFeePerGas,\n        uint256 gasLimit,\n        bytes memory signatures\n    ) external;\n}\n"
    },
    "contracts/interfaces/ILaserModuleSSR.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity 0.8.15;\n\nimport \"./IERC165.sol\";\n\ninterface ILaserModuleSSR {\n    error SSR__onlyWallet__notWallet();\n\n    error SSR__initGuardians__underflow();\n\n    error SSR__initRecoveryOwners__underflow();\n\n    error SSR__verifyNewRecoveryOwnerOrGuardian__invalidAddress();\n\n    ///@dev removeGuardian() custom errors.\n    error SSR__removeGuardian__underflow();\n    error SSR__removeGuardian__invalidAddress();\n    error SSR__removeGuardian__incorrectPreviousGuardian();\n\n    ///@dev removeRecoveryOwner() custom errors.\n    error SSR__removeRecoveryOwner__underflow();\n    error SSR__removeRecoveryOwner__invalidAddress();\n    error SSR__removeRecoveryOwner__incorrectPreviousRecoveryOwner();\n\n    ///@dev swapGuardian() custom errors.\n    error SSR__swapGuardian__invalidPrevGuardian();\n    error SSR__swapGuardian__invalidOldGuardian();\n\n    ///@dev swapRecoveryOwner() custom errors.\n    error SSR__swapRecoveryOwner__invalidPrevRecoveryOwner();\n    error SSR__swapRecoveryOwner__invalidOldRecoveryOwner();\n\n    ///@dev Inits the module.\n    ///@notice The target wallet is the 'msg.sender'.\n    function initSSR(address[] calldata _guardians, address[] calldata _recoveryOwners) external;\n\n    function lock(\n        address wallet,\n        bytes calldata callData,\n        uint256 maxFeePerGas,\n        uint256 maxPriorityFeePerGas,\n        uint256 gasLimit,\n        address relayer,\n        bytes memory signatures\n    ) external;\n\n    /**\n     * @dev Unlocks the target wallet.\n     * @notice Can only be called with the signature of the wallet's owner + recovery owner or  owner + guardian.\n     */\n    function unlock(\n        address wallet,\n        bytes calldata callData,\n        uint256 maxFeePerGas,\n        uint256 maxPriorityFeePerGas,\n        uint256 gasLimit,\n        address relayer,\n        bytes memory signatures\n    ) external;\n\n    function recover(\n        address wallet,\n        bytes calldata callData,\n        uint256 maxFeePerGas,\n        uint256 maxPriorityFeePerGas,\n        uint256 gasLimit,\n        address relayer,\n        bytes memory signatures\n    ) external;\n\n    ///@dev Returns the chain id of this.\n    function getChainId() external view returns (uint256 chainId);\n\n    function getGuardians(address wallet) external view returns (address[] memory);\n\n    function getRecoveryOwners(address wallet) external view returns (address[] memory);\n\n    function getWalletTimeLock(address wallet) external view returns (uint256);\n\n    function isGuardian(address wallet, address guardian) external view returns (bool);\n}\n"
    },
    "contracts/modules/laser-modules/LaserModuleSSR.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity 0.8.15;\n\nimport \"../../common/Utils.sol\";\nimport \"../../interfaces/ILaserModuleSSR.sol\";\nimport \"../../interfaces/ILaserState.sol\";\nimport \"../../interfaces/ILaserWallet.sol\";\n\n////////////\n///// TODO: Adding and removing a guardian or recovery owner should\n// only be allowed when the wallet is unlocked.\ncontract LaserModuleSSR is ILaserModuleSSR {\n    bytes32 private constant DOMAIN_SEPARATOR_TYPEHASH =\n        keccak256(\"EIP712Domain(uint256 chainId,address verifyingContract)\");\n\n    bytes32 private constant LASER_MODULE_SSR_TYPE_STRUCTURE =\n        keccak256(\n            \"LaserModuleSSR(address wallet,bytes callData,uint256 walletNonce,uint256 maxFeePerGas,uint256 maxPriorityFeePerGas,uint256 gasLimit\"\n        );\n\n    ///@dev POINTER to create a mapping link list.\n    address internal constant POINTER = address(0x1);\n\n    ///@dev timeLock keeps track of the recovery time delay. It gets set to 'block.timestamp' when 'lock' is triggered.\n    mapping(address => uint256) internal timeLock;\n\n    mapping(address => uint256) internal recoveryOwnerCount;\n\n    mapping(address => uint256) internal guardianCount;\n\n    mapping(address => mapping(address => address)) internal recoveryOwners;\n\n    mapping(address => mapping(address => address)) internal guardians;\n\n    modifier onlyWallet(address wallet) {\n        if (msg.sender != wallet) revert SSR__onlyWallet__notWallet();\n\n        _;\n    }\n\n    ///@dev Inits the module.\n    ///@notice The target wallet is the 'msg.sender'.\n    function initSSR(address[] calldata _guardians, address[] calldata _recoveryOwners) external {\n        address wallet = msg.sender;\n\n        initGuardians(wallet, _guardians);\n        initRecoveryOwners(wallet, _recoveryOwners);\n    }\n\n    ///@dev Locks the target wallet.\n    ///Can only be called by the recovery owner + guardian.\n    function lock(\n        address wallet,\n        bytes calldata callData,\n        uint256 maxFeePerGas,\n        uint256 maxPriorityFeePerGas,\n        uint256 gasLimit,\n        address relayer,\n        bytes memory signatures\n    ) external {\n        uint256 walletNonce = ILaserState(wallet).nonce();\n\n        bytes32 signedHash = keccak256(\n            encodeOperation(wallet, callData, walletNonce, maxFeePerGas, maxPriorityFeePerGas, gasLimit)\n        );\n\n        require(bytes4(callData) == bytes4(keccak256(\"lock()\")), \"should be the same!\");\n\n        address signer1 = Utils.returnSigner(signedHash, signatures, 0);\n        require(recoveryOwners[wallet][signer1] != address(0));\n\n        address signer2 = Utils.returnSigner(signedHash, signatures, 1);\n        require(guardians[wallet][signer2] != address(0));\n\n        timeLock[wallet] = block.timestamp;\n\n        ILaserWallet(wallet).execFromModule(wallet, 0, callData, maxFeePerGas, maxPriorityFeePerGas, gasLimit, relayer);\n    }\n\n    /**\n     * @dev Unlocks the target wallet.\n     * @notice Can only be called with the signature of the wallet's owner + recovery owner or  owner + guardian.\n     */\n    function unlock(\n        address wallet,\n        bytes calldata callData,\n        uint256 maxFeePerGas,\n        uint256 maxPriorityFeePerGas,\n        uint256 gasLimit,\n        address relayer,\n        bytes memory signatures\n    ) external {\n        uint256 walletNonce = ILaserState(wallet).nonce();\n\n        bytes32 signedHash = keccak256(\n            encodeOperation(wallet, callData, walletNonce, maxFeePerGas, maxPriorityFeePerGas, gasLimit)\n        );\n\n        require(bytes4(callData) == bytes4(keccak256(\"unlock()\")), \"should be the same!\");\n\n        address walletOwner = ILaserState(wallet).owner();\n        require(walletOwner != address(0));\n\n        address signer1 = Utils.returnSigner(signedHash, signatures, 0);\n        require(signer1 == walletOwner);\n\n        address signer2 = Utils.returnSigner(signedHash, signatures, 1);\n        require(\n            guardians[wallet][signer2] != address(0) || recoveryOwners[wallet][signer2] != address(0),\n            \"nop signer2\"\n        );\n\n        timeLock[wallet] = 0;\n        ILaserWallet(wallet).execFromModule(wallet, 0, callData, maxFeePerGas, maxPriorityFeePerGas, gasLimit, relayer);\n    }\n\n    function recover(\n        address wallet,\n        bytes calldata callData,\n        uint256 maxFeePerGas,\n        uint256 maxPriorityFeePerGas,\n        uint256 gasLimit,\n        address relayer,\n        bytes memory signatures\n    ) external {\n        uint256 walletNonce = ILaserState(wallet).nonce();\n\n        bytes32 signedHash = keccak256(\n            encodeOperation(wallet, callData, walletNonce, maxFeePerGas, maxPriorityFeePerGas, gasLimit)\n        );\n\n        require(bytes4(callData) == bytes4(keccak256(\"changeOwner(address)\")), \"should be change owner.\");\n\n        address signer1 = Utils.returnSigner(signedHash, signatures, 0);\n        require(recoveryOwners[wallet][signer1] != address(0));\n\n        address signer2 = Utils.returnSigner(signedHash, signatures, 1);\n        require(guardians[wallet][signer2] != address(0), \"nop signer2\");\n\n        require(timeLock[wallet] + 1 weeks < block.timestamp, \"incorrect time\");\n        timeLock[wallet] = 0;\n        ILaserWallet(wallet).execFromModule(wallet, 0, callData, maxFeePerGas, maxPriorityFeePerGas, gasLimit, relayer);\n    }\n\n    function addGuardian(address wallet, address newGuardian) external onlyWallet(wallet) {\n        verifyNewRecoveryOwnerOrGuardian(wallet, newGuardian);\n        guardians[wallet][newGuardian] = guardians[wallet][POINTER];\n        guardians[wallet][POINTER] = newGuardian;\n\n        unchecked {\n            guardianCount[wallet]++;\n        }\n    }\n\n    function removeGuardian(\n        address wallet,\n        address prevGuardian,\n        address guardianToRemove\n    ) external onlyWallet(wallet) {\n        // There needs to be at least 1 guardian.\n        if (guardianCount[wallet] < 2) revert SSR__removeGuardian__underflow();\n\n        if (guardianToRemove == POINTER) revert SSR__removeGuardian__invalidAddress();\n\n        if (guardians[wallet][prevGuardian] != guardianToRemove)\n            revert SSR__removeGuardian__incorrectPreviousGuardian();\n\n        guardians[wallet][prevGuardian] = guardians[wallet][guardianToRemove];\n        guardians[wallet][guardianToRemove] = address(0);\n\n        unchecked {\n            // Can't underflow, there needs to be more than 2 guardians to reach here.\n            guardianCount[wallet]--;\n        }\n    }\n\n    function swapGuardian(\n        address wallet,\n        address prevGuardian,\n        address newGuardian,\n        address oldGuardian\n    ) external onlyWallet(wallet) {\n        verifyNewRecoveryOwnerOrGuardian(wallet, newGuardian);\n\n        if (guardians[wallet][prevGuardian] != oldGuardian) revert SSR__swapGuardian__invalidPrevGuardian();\n\n        if (oldGuardian == POINTER) revert SSR__swapGuardian__invalidOldGuardian();\n\n        guardians[wallet][newGuardian] = guardians[wallet][oldGuardian];\n        guardians[wallet][prevGuardian] = newGuardian;\n        guardians[wallet][oldGuardian] = address(0);\n    }\n\n    function addRecoveryOwner(address wallet, address newRecoveryOwner) external onlyWallet(wallet) {\n        verifyNewRecoveryOwnerOrGuardian(wallet, newRecoveryOwner);\n        recoveryOwners[wallet][newRecoveryOwner] = recoveryOwners[wallet][POINTER];\n        recoveryOwners[wallet][POINTER] = newRecoveryOwner;\n\n        unchecked {\n            recoveryOwnerCount[wallet]++;\n        }\n    }\n\n    function removeRecoveryOwner(\n        address wallet,\n        address prevRecoveryOwner,\n        address recoveryOwnerToRemove\n    ) external onlyWallet(wallet) {\n        // There needs to be at least 1 recovery owner.\n        if (recoveryOwnerCount[wallet] < 2) revert SSR__removeRecoveryOwner__underflow();\n\n        if (recoveryOwnerToRemove == POINTER) revert SSR__removeRecoveryOwner__invalidAddress();\n\n        if (recoveryOwners[wallet][prevRecoveryOwner] != recoveryOwnerToRemove) {\n            revert SSR__removeRecoveryOwner__incorrectPreviousRecoveryOwner();\n        }\n\n        recoveryOwners[wallet][prevRecoveryOwner] = recoveryOwners[wallet][recoveryOwnerToRemove];\n        recoveryOwners[wallet][recoveryOwnerToRemove] = address(0);\n\n        unchecked {\n            // Can't underflow, there needs to be more than 2 guardians to reach here.\n            recoveryOwnerCount[wallet]--;\n        }\n    }\n\n    function swapRecoveryOwner(\n        address wallet,\n        address prevRecoveryOwner,\n        address newRecoveryOwner,\n        address oldRecoveryOwner\n    ) external onlyWallet(wallet) {\n        verifyNewRecoveryOwnerOrGuardian(wallet, newRecoveryOwner);\n        if (recoveryOwners[wallet][prevRecoveryOwner] != oldRecoveryOwner) {\n            revert SSR__swapRecoveryOwner__invalidPrevRecoveryOwner();\n        }\n\n        if (oldRecoveryOwner == POINTER) revert SSR__swapRecoveryOwner__invalidOldRecoveryOwner();\n\n        recoveryOwners[wallet][newRecoveryOwner] = recoveryOwners[wallet][oldRecoveryOwner];\n        recoveryOwners[wallet][prevRecoveryOwner] = newRecoveryOwner;\n        recoveryOwners[wallet][oldRecoveryOwner] = address(0);\n    }\n\n    function getGuardians(address wallet) external view returns (address[] memory) {\n        address[] memory guardiansArray = new address[](guardianCount[wallet]);\n        address currentGuardian = guardians[wallet][POINTER];\n\n        uint256 index;\n        while (currentGuardian != POINTER) {\n            guardiansArray[index] = currentGuardian;\n            currentGuardian = guardians[wallet][currentGuardian];\n            unchecked {\n                ++index;\n            }\n        }\n        return guardiansArray;\n    }\n\n    function getRecoveryOwners(address wallet) external view returns (address[] memory) {\n        address[] memory recoveryOwnersArray = new address[](recoveryOwnerCount[wallet]);\n        address currentRecoveryOwner = recoveryOwners[wallet][POINTER];\n\n        uint256 index;\n        while (currentRecoveryOwner != POINTER) {\n            recoveryOwnersArray[index] = currentRecoveryOwner;\n            currentRecoveryOwner = recoveryOwners[wallet][currentRecoveryOwner];\n            unchecked {\n                ++index;\n            }\n        }\n        return recoveryOwnersArray;\n    }\n\n    function getWalletTimeLock(address wallet) external view returns (uint256) {\n        return timeLock[wallet];\n    }\n\n    function isGuardian(address wallet, address guardian) external view returns (bool) {\n        return guardians[wallet][guardian] != address(0) && guardian != POINTER;\n    }\n\n    function initGuardians(address wallet, address[] calldata _guardians) internal {\n        uint256 guardiansLength = _guardians.length;\n\n        if (guardiansLength < 1) revert SSR__initGuardians__underflow();\n\n        address currentGuardian = POINTER;\n        address guardian;\n\n        for (uint256 i = 0; i < guardiansLength; ) {\n            guardian = _guardians[i];\n\n            guardians[wallet][currentGuardian] = guardian;\n            currentGuardian = guardian;\n\n            verifyNewRecoveryOwnerOrGuardian(wallet, guardian);\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        guardians[wallet][currentGuardian] = POINTER;\n        guardianCount[wallet] = guardiansLength;\n    }\n\n    ///@dev Inits the recovery owners for the target wallet.\n    ///@param wallet The target wallet address.\n    ///@param _recoveryOwners Array of the recovery owners addresses.\n    function initRecoveryOwners(address wallet, address[] calldata _recoveryOwners) internal {\n        uint256 recoveryOwnersLength = _recoveryOwners.length;\n\n        if (recoveryOwnersLength < 1) revert SSR__initRecoveryOwners__underflow();\n\n        address currentRecoveryOwner = POINTER;\n        address recoveryOwner;\n\n        for (uint256 i = 0; i < recoveryOwnersLength; ) {\n            recoveryOwner = _recoveryOwners[i];\n\n            recoveryOwners[wallet][currentRecoveryOwner] = recoveryOwner;\n            currentRecoveryOwner = recoveryOwner;\n\n            verifyNewRecoveryOwnerOrGuardian(wallet, recoveryOwner);\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        recoveryOwners[wallet][currentRecoveryOwner] = POINTER;\n        recoveryOwnerCount[wallet] = recoveryOwnersLength;\n    }\n\n    function verifyNewRecoveryOwnerOrGuardian(address wallet, address toVerify) internal view {\n        address owner = ILaserState(wallet).owner();\n\n        if (toVerify.code.length > 0) {\n            // If the recovery owner is a smart contract wallet, it needs to support EIP1271.\n            if (!IERC165(toVerify).supportsInterface(0x1626ba7e)) {\n                revert SSR__verifyNewRecoveryOwnerOrGuardian__invalidAddress();\n            }\n        }\n        if (\n            toVerify == address(0) ||\n            toVerify == owner ||\n            guardians[wallet][toVerify] != address(0) ||\n            recoveryOwners[wallet][toVerify] != address(0)\n        ) revert SSR__verifyNewRecoveryOwnerOrGuardian__invalidAddress();\n    }\n\n    ///@dev Returns the chain id of this.\n    function getChainId() public view returns (uint256 chainId) {\n        return block.chainid;\n    }\n\n    function domainSeparator() public view returns (bytes32) {\n        return keccak256(abi.encode(DOMAIN_SEPARATOR_TYPEHASH, getChainId(), address(this)));\n    }\n\n    function encodeOperation(\n        address wallet,\n        bytes calldata callData,\n        uint256 walletNonce,\n        uint256 maxFeePerGas,\n        uint256 maxPriorityFeePerGas,\n        uint256 gasLimit\n    ) internal view returns (bytes memory) {\n        bytes32 opHash = keccak256(\n            abi.encode(\n                LASER_MODULE_SSR_TYPE_STRUCTURE,\n                wallet,\n                keccak256(callData),\n                walletNonce,\n                maxFeePerGas,\n                maxPriorityFeePerGas,\n                gasLimit\n            )\n        );\n\n        return abi.encodePacked(bytes1(0x19), bytes1(0x01), domainSeparator(), opHash);\n    }\n\n    function operationHash(\n        address wallet,\n        bytes calldata callData,\n        uint256 walletNonce,\n        uint256 maxFeePerGas,\n        uint256 maxPriorityFeePerGas,\n        uint256 gasLimit\n    ) external view returns (bytes32) {\n        return keccak256(encodeOperation(wallet, callData, walletNonce, maxFeePerGas, maxPriorityFeePerGas, gasLimit));\n    }\n}\n"
    },
    "contracts/interfaces/ILaserWallet.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.15;\n\n/**\n * @title  ILaserWallet\n *\n * @author Rodrigo Herrera I.\n *\n * @notice Laser is a modular smart contract wallet made for the Ethereum Virtual Machine.\n *         It has modularity (programmability) and security at its core.\n *\n * @dev    This interface has all events, errors, and external function for LaserWallet.\n */\ninterface ILaserWallet {\n    event Setup(address owner, address laserModule);\n    event ExecSuccess(address to, uint256 value, uint256 nonce);\n    event ExecFailure(address to, uint256 value, uint256 nonce);\n\n    // init() custom errors.\n    error LW__init__notOwner();\n    error LW__init__refundFailure();\n\n    // exec() custom errors.\n    error LW__exec__invalidNonce();\n    error LW__exec__walletLocked();\n    error LW__exec__notOwner();\n    error LW__exec__refundFailure();\n\n    // execFromModule() custom errors.\n    error LW__execFromModule__unauthorizedModule();\n    error LW__execFromModule__mainCallFailed();\n    error LW__execFromModule__refundFailure();\n\n    // simulateTransaction() custom errors.\n    error LW__SIMULATION__invalidNonce();\n    error LW__SIMULATION__walletLocked();\n    error LW__SIMULATION__notOwner();\n    error LW__SIMULATION__refundFailure();\n\n    // isValidSignature() Laser custom error.\n    error LaserWallet__invalidSignature();\n\n    struct Transaction {\n        address to;\n        uint256 value;\n        bytes callData;\n        uint256 nonce;\n        uint256 maxFeePerGas;\n        uint256 maxPriorityFeePerGas;\n        uint256 gasLimit;\n        address relayer;\n        bytes signatures;\n    }\n\n    /**\n     * @notice Setup function, sets initial storage of the wallet.\n     *         It can't be called after initialization.\n     *\n     * @param _owner                        The owner of the wallet.\n     * @param maxFeePerGas                  Maximum WEI the owner is willing to pay per unit of gas.\n     * @param maxPriorityFeePerGas          Miner's tip.\n     * @param gasLimit                      Maximum amount of gas the owner is willing to use for this transaction.\n     * @param relayer                       Address to refund for the inclusion of this transaction.\n     * @param smartSocialRecoveryModule     Address of the initial module to setup -> Smart Social Recovery.\n     * @param _laserMasterGuard             Address of the parent guard module 'LaserMasterGuard'.\n     * @param laserVault                    Address of the guard sub-module 'LaserVault'.\n     * @param _laserRegistry                Address of the Laser registry: module that keeps track of authorized modules.\n     * @param smartSocialRecoveryInitData   Initialization data for the provided module.\n     * @param ownerSignature                Signature of the owner that validates approval for initialization.\n     */\n    function init(\n        address _owner,\n        uint256 maxFeePerGas,\n        uint256 maxPriorityFeePerGas,\n        uint256 gasLimit,\n        address relayer,\n        address smartSocialRecoveryModule,\n        address _laserMasterGuard,\n        address laserVault,\n        address _laserRegistry,\n        bytes calldata smartSocialRecoveryInitData,\n        bytes memory ownerSignature\n    ) external;\n\n    /**\n     * @notice Executes a generic transaction.\n     *         If 'gasLimit' does not match the actual gas limit of the transaction, the relayer can incur losses.\n     *         It is the relayer's responsability to make sure that they are the same,\n     *         the user does not get affected if a mistake is made.\n     *\n     * @param to                    Destination address.\n     * @param value                 Amount in WEI to transfer.\n     * @param callData              Data payload for the transaction.\n     * @param _nonce                Anti-replay number.\n     * @param maxFeePerGas          Maximum WEI the owner is willing to pay per unit of gas.\n     * @param maxPriorityFeePerGas  Miner's tip.\n     * @param gasLimit              Maximum amount of gas the owner is willing to use for this transaction.\n     * @param relayer               Address to refund for the inclusion of this transaction.\n     * @param signatures            The signature(s) of the hash for this transaction.\n     */\n    function exec(\n        address to,\n        uint256 value,\n        bytes calldata callData,\n        uint256 _nonce,\n        uint256 maxFeePerGas,\n        uint256 maxPriorityFeePerGas,\n        uint256 gasLimit,\n        address relayer,\n        bytes calldata signatures\n    ) external returns (bool success);\n\n    /**\n     * @notice Executes a transaction from an authorized module.\n     *         If 'gasLimit' does not match the actual gas limit of the transaction, the relayer can incur losses.\n     *         It is the relayer's responsability to make sure that they are the same,\n     *         the user does not get affected if a mistake is made.\n     *\n     * @param to                    Destination address.\n     * @param value                 Amount in WEI to transfer.\n     * @param callData              Data payload for the transaction.\n     * @param maxFeePerGas          Maximum WEI the owner is willing to pay per unit of gas.\n     * @param maxPriorityFeePerGas  Miner's tip.\n     * @param gasLimit              Maximum amount of gas the owner is willing to use for this transaction.\n     * @param relayer               Address to refund for the inclusion of this transaction.\n     */\n    function execFromModule(\n        address to,\n        uint256 value,\n        bytes calldata callData,\n        uint256 maxFeePerGas,\n        uint256 maxPriorityFeePerGas,\n        uint256 gasLimit,\n        address relayer\n    ) external;\n\n    /**\n     * @notice Simulates a transaction.\n     *         It needs to be called off-chain from address(0).\n     *\n     * @param to                    Destination address.\n     * @param value                 Amount in WEI to transfer.\n     * @param callData              Data payload for the transaction.\n     * @param _nonce                Anti-replay number.\n     * @param maxFeePerGas          Maximum WEI the owner is willing to pay per unit of gas.\n     * @param maxPriorityFeePerGas  Miner's tip.\n     * @param gasLimit              Maximum amount of gas the owner is willing to use for this transaction.\n     * @param relayer               Address to refund for the inclusion of this transaction.\n     * @param signatures            The signature(s) of the hash of this transaction.\n     *\n     * @return gasUsed The gas used for this transaction.\n     */\n    function simulateTransaction(\n        address to,\n        uint256 value,\n        bytes calldata callData,\n        uint256 _nonce,\n        uint256 maxFeePerGas,\n        uint256 maxPriorityFeePerGas,\n        uint256 gasLimit,\n        address relayer,\n        bytes calldata signatures\n    ) external returns (uint256 gasUsed);\n\n    /**\n     * @notice Locks the wallet. Once locked, only the SSR module can unlock it or recover it.\n     *\n     * @dev Can only be called by address(this).\n     */\n    function lock() external;\n\n    /**\n     * @notice Unlocks the wallet. Can only be unlocked or recovered from the SSR module.\n     *\n     * @dev Can only be called by address(this).\n     */\n    function unlock() external;\n\n    /**\n     * @notice Should return whether the signature provided is valid for the provided hash.\n     *\n     * @param hash      Hash of the data to be signed.\n     * @param signature Signature byte array associated with hash.\n     *\n     * MUST return the bytes4 magic value 0x1626ba7e when function passes.\n     * MUST NOT modify state (using STATICCALL for solc < 0.5, view modifier for solc > 0.5)\n     * MUST allow external calls\n     *\n     * @return Magic value if signature matches the owner's address and the wallet is not locked.\n     */\n    function isValidSignature(bytes32 hash, bytes memory signature) external view returns (bytes4);\n\n    /**\n     * @notice Returns the hash to be signed to execute a transaction.\n     */\n    function operationHash(\n        address to,\n        uint256 value,\n        bytes calldata callData,\n        uint256 _nonce,\n        uint256 maxFeePerGas,\n        uint256 maxPriorityFeePerGas,\n        uint256 gasLimit\n    ) external view returns (bytes32);\n\n    /**\n     * @return chainId The chain id of this.\n     */\n    function getChainId() external view returns (uint256 chainId);\n\n    /**\n     * @notice Domain separator for this wallet.\n     */\n    function domainSeparator() external view returns (bytes32);\n}\n"
    },
    "contracts/proxies/LaserFactory.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity 0.8.15;\n\nimport \"../interfaces/IERC165.sol\";\nimport \"../interfaces/ILaserFactory.sol\";\nimport \"../interfaces/ILaserWallet.sol\";\n\n/**\n * @title LaserFactory\n *\n * @notice Factory that creates new Laser proxies, and has helper methods.\n */\ncontract LaserFactory is ILaserFactory {\n    address public immutable singleton;\n\n    address public immutable laserRegistry;\n\n    address public immutable laserMasterGuard;\n\n    /// @param _singleton Master copy of the proxy.\n    constructor(\n        address _singleton,\n        address _laserRegistry,\n        address _laserMasterGuard\n    ) {\n        // Laser Wallet contract: bytes4(keccak256(\"I_AM_LASER\"))\n        if (!IERC165(_singleton).supportsInterface(0xae029e0b)) revert LaserFactory__constructor__invalidSingleton();\n        singleton = _singleton;\n        laserRegistry = _laserRegistry;\n        laserMasterGuard = _laserMasterGuard;\n    }\n\n    function deployProxyAndRefund(\n        address owner,\n        uint256 maxFeePerGas,\n        uint256 maxPriorityFeePerGas,\n        uint256 gasLimit,\n        address relayer,\n        address smartSocialRecoveryModule,\n        address laserVault,\n        bytes memory smartSocialRecoveryInitData,\n        uint256 saltNumber,\n        bytes memory ownerSignature\n    ) external returns (LaserProxy proxy) {\n        {\n            bytes32 salt = getSalt(owner, smartSocialRecoveryModule, smartSocialRecoveryInitData, saltNumber);\n            proxy = createProxyWithCreate2(salt);\n\n            ILaserWallet(address(proxy)).init(\n                owner,\n                maxFeePerGas,\n                maxPriorityFeePerGas,\n                gasLimit,\n                relayer,\n                smartSocialRecoveryModule,\n                laserMasterGuard,\n                laserVault,\n                laserRegistry,\n                smartSocialRecoveryInitData,\n                ownerSignature\n            );\n\n            emit ProxyCreation(address(proxy));\n        }\n    }\n\n    ///@dev Precomputes the address of a proxy that is created through 'create2'.\n    function preComputeAddress(\n        address owner,\n        address laserModule,\n        bytes calldata laserModuleData,\n        uint256 saltNumber\n    ) external view returns (address) {\n        bytes memory creationCode = proxyCreationCode();\n        bytes memory data = abi.encodePacked(creationCode, uint256(uint160(singleton)));\n\n        bytes32 salt = getSalt(owner, laserModule, laserModuleData, saltNumber);\n        bytes32 hash = keccak256(abi.encodePacked(bytes1(0xff), address(this), salt, keccak256(data)));\n\n        return address(uint160(uint256(hash)));\n    }\n\n    ///@dev Allows to retrieve the runtime code of a deployed Proxy. This can be used to check that the expected Proxy was deployed.\n    function proxyRuntimeCode() external pure returns (bytes memory) {\n        return type(LaserProxy).runtimeCode;\n    }\n\n    ///@dev Allows to retrieve the creation code used for the Proxy deployment. With this it is easily possible to calculate predicted address.\n    function proxyCreationCode() public pure returns (bytes memory) {\n        return type(LaserProxy).creationCode;\n    }\n\n    ///@dev Allows to create new proxy contact using CREATE2 but it doesn't run the initializer.\n    ///This method is only meant as an utility to be called from other methods.\n    function createProxyWithCreate2(bytes32 salt) internal returns (LaserProxy proxy) {\n        bytes memory deploymentData = abi.encodePacked(type(LaserProxy).creationCode, uint256(uint160(singleton)));\n        assembly {\n            proxy := create2(0x0, add(0x20, deploymentData), mload(deploymentData), salt)\n        }\n        //@todo change the custom error name.\n        if (address(proxy) == address(0)) revert LaserFactory__create2Failed();\n    }\n\n    /**\n     * @dev Generates the salt for deployment.\n     */\n    function getSalt(\n        address owner,\n        address laserModule,\n        bytes memory laserModuleData,\n        uint256 saltNumber\n    ) internal pure returns (bytes32 salt) {\n        salt = keccak256(abi.encodePacked(owner, laserModule, laserModuleData, saltNumber));\n    }\n}\n"
    },
    "contracts/interfaces/ILaserFactory.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity 0.8.15;\n\nimport \"../proxies/LaserProxy.sol\";\n\n///@title ILaserFactory.\n///@notice Has all the external functions, events and errors for ProxyFactory.sol.\ninterface ILaserFactory {\n    event ProxyCreation(address proxy);\n\n    ///@dev constructor() custom error.\n    error LaserFactory__constructor__invalidSingleton();\n\n    ///@dev createProxyWithCreate2() custom error.\n    error LaserFactory__create2Failed();\n\n    ///@dev Creates a new proxy with create 2, initializes the wallet and refunds the relayer.\n    function deployProxyAndRefund(\n        address owner,\n        uint256 maxFeePerGas,\n        uint256 maxPriorityFeePerGas,\n        uint256 gasLimit,\n        address relayer,\n        address smartSocialRecoveryModule,\n        address laserVault,\n        bytes calldata smartSocialRecoveryInitData,\n        uint256 saltNumber,\n        bytes memory ownerSignature\n    ) external returns (LaserProxy proxy);\n\n    ///@dev Precomputes the address of a proxy that is created through 'create2'.\n    function preComputeAddress(\n        address owner,\n        address laserModule,\n        bytes calldata laserModuleData,\n        uint256 saltNumber\n    ) external view returns (address);\n\n    ///@dev Allows to retrieve the runtime code of a deployed Proxy. This can be used to check that the expected Proxy was deployed.\n    function proxyRuntimeCode() external pure returns (bytes memory);\n\n    ///@dev Allows to retrieve the creation code used for the Proxy deployment. With this it is easily possible to calculate predicted address.\n    function proxyCreationCode() external pure returns (bytes memory);\n}\n"
    },
    "contracts/proxies/LaserProxy.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity 0.8.15;\n\n/**\n * @title LaserProxy\n *\n * @notice Proxy contract that delegates all calls to a master copy.\n */\ncontract LaserProxy {\n    // The singleton always needs to be at storage slot 0.\n    address internal singleton;\n\n    /**\n     * @param _singleton Singleton address.\n     */\n    constructor(address _singleton) {\n        // The proxy creation is done through the LaserProxyFactory.\n        // The singleton is created at the factory's creation, so there is no need to do checks here.\n        singleton = _singleton;\n    }\n\n    /**\n     * @dev Fallback function forwards all transactions and returns all received return data.\n     */\n    fallback() external payable {\n        address _singleton = singleton;\n        assembly {\n            calldatacopy(0, 0, calldatasize())\n            let success := delegatecall(gas(), _singleton, 0, calldatasize(), 0, 0)\n            returndatacopy(0, 0, returndatasize())\n            if eq(success, 0) {\n                revert(0, returndatasize())\n            }\n            return(0, returndatasize())\n        }\n    }\n}\n"
    },
    "contracts/handlers/Handler.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.15;\n\nimport \"../interfaces/IHandler.sol\";\nimport \"../interfaces/IERC165.sol\";\n\n/**\n * @title Handler - Supports token callbacks.\n */\ncontract Handler is IHandler, IERC165 {\n    function onERC721Received(\n        address,\n        address,\n        uint256,\n        bytes calldata\n    ) external pure returns (bytes4) {\n        return 0x150b7a02;\n    }\n\n    function onERC1155Received(\n        address,\n        address,\n        uint256,\n        uint256,\n        bytes calldata\n    ) external pure returns (bytes4) {\n        return 0xf23a6e61;\n    }\n\n    function onERC1155BatchReceived(\n        address,\n        address,\n        uint256[] calldata,\n        uint256[] calldata,\n        bytes calldata\n    ) external pure returns (bytes4 result) {\n        return 0xbc197c81;\n    }\n\n    function tokensReceived(\n        address,\n        address,\n        address,\n        uint256,\n        bytes calldata,\n        bytes calldata\n    ) external pure {}\n\n    function supportsInterface(bytes4 _interfaceId) external pure returns (bool) {\n        return\n            _interfaceId == 0x01ffc9a7 || // ERC165 interface ID for ERC165.\n            _interfaceId == 0x1626ba7e || // EIP 1271.\n            _interfaceId == 0xd9b67a26 || // ERC165 interface ID for ERC1155.\n            _interfaceId == 0x4e2312e0 || // ERC-1155 `ERC1155TokenReceiver` support.\n            _interfaceId == 0xae029e0b || // Laser Wallet contract: bytes4(keccak256(\"I_AM_LASER\")).\n            _interfaceId == 0x150b7a02; // ERC721 onErc721Received.\n    }\n}\n"
    },
    "contracts/interfaces/IHandler.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity 0.8.15;\n\n///@title IHandler\n///@notice Has all the external functions for Handler.sol.\ninterface IHandler {\n    function onERC721Received(\n        address,\n        address,\n        uint256,\n        bytes calldata\n    ) external pure returns (bytes4);\n\n    function onERC1155Received(\n        address,\n        address,\n        uint256,\n        uint256,\n        bytes calldata\n    ) external pure returns (bytes4 result);\n\n    function onERC1155BatchReceived(\n        address,\n        address,\n        uint256[] calldata,\n        uint256[] calldata,\n        bytes calldata\n    ) external pure returns (bytes4 result);\n\n    function tokensReceived(\n        address,\n        address,\n        address,\n        uint256,\n        bytes calldata,\n        bytes calldata\n    ) external pure;\n}\n"
    },
    "contracts/LaserWallet.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity 0.8.15;\n\nimport \"./handlers/Handler.sol\";\nimport \"./interfaces/ILaserGuard.sol\";\nimport \"./interfaces/ILaserWallet.sol\";\nimport \"./state/LaserState.sol\";\n\n/**\n * @title  LaserWallet\n *\n * @author Rodrigo Herrera I.\n *\n * @notice Laser is a modular smart contract wallet made for the Ethereum Virtual Machine.\n *         It has modularity (programmability) and security at its core.\n */\ncontract LaserWallet is ILaserWallet, LaserState, Handler {\n    /*//////////////////////////////////////////////////////////////\n                            Laser metadata\n    //////////////////////////////////////////////////////////////*/\n\n    string public constant VERSION = \"1.0.0\";\n\n    string public constant NAME = \"Laser Wallet\";\n\n    /*//////////////////////////////////////////////////////////////\n                        Signature constant helpers\n    //////////////////////////////////////////////////////////////*/\n\n    bytes4 private constant EIP1271_MAGIC_VALUE = bytes4(keccak256(\"isValidSignature(bytes32,bytes)\"));\n\n    bytes32 private constant DOMAIN_SEPARATOR_TYPEHASH =\n        keccak256(\"EIP712Domain(uint256 chainId,address verifyingContract)\");\n\n    bytes32 private constant LASER_TYPE_STRUCTURE =\n        keccak256(\n            \"LaserOperation(address to,uint256 value,bytes callData,uint256 nonce,uint256 maxFeePerGas,uint256 maxPriorityFeePerGas,uint256 gasLimit)\"\n        );\n\n    /**\n     * @dev Sets the owner of the implementation address (singleton) to 'this'.\n     *      This will make the base contract unusable, even though it does not have 'delegatecall'.\n     */\n    constructor() {\n        owner = address(this);\n    }\n\n    receive() external payable {}\n\n    /**\n     * @notice Setup function, sets initial storage of the wallet.\n     *         It can't be called after initialization.\n     *\n     * @param _owner                        The owner of the wallet.\n     * @param maxFeePerGas                  Maximum WEI the owner is willing to pay per unit of gas.\n     * @param maxPriorityFeePerGas          Miner's tip.\n     * @param gasLimit                      Maximum amount of gas the owner is willing to use for this transaction.\n     * @param relayer                       Address to refund for the inclusion of this transaction.\n     * @param smartSocialRecoveryModule     Address of the initial module to setup -> Smart Social Recovery.\n     * @param _laserMasterGuard             Address of the parent guard module 'LaserMasterGuard'.\n     * @param laserVault                    Address of the guard sub-module 'LaserVault'.\n     * @param _laserRegistry                Address of the Laser registry: module that keeps track of authorized modules.\n     * @param smartSocialRecoveryInitData   Initialization data for the provided module.\n     * @param ownerSignature                Signature of the owner that validates approval for initialization.\n     */\n    function init(\n        address _owner,\n        uint256 maxFeePerGas,\n        uint256 maxPriorityFeePerGas,\n        uint256 gasLimit,\n        address relayer,\n        address smartSocialRecoveryModule,\n        address _laserMasterGuard,\n        address laserVault,\n        address _laserRegistry,\n        bytes calldata smartSocialRecoveryInitData,\n        bytes memory ownerSignature\n    ) external {\n        // activateWallet verifies that the current owner is address 0, reverts otherwise.\n        // This is more than enough to avoid being called after initialization.\n        activateWallet(\n            _owner,\n            smartSocialRecoveryModule,\n            _laserMasterGuard,\n            laserVault,\n            _laserRegistry,\n            smartSocialRecoveryInitData\n        );\n\n        // This is to ensure that the owner authorized the amount of gas.\n        {\n            bytes32 signedHash = keccak256(\n                abi.encodePacked(maxFeePerGas, maxPriorityFeePerGas, gasLimit, block.chainid, address(this))\n            );\n\n            address signer = Utils.returnSigner(signedHash, ownerSignature, 0);\n            if (signer != _owner) revert LW__init__notOwner();\n        }\n\n        if (gasLimit > 0) {\n            // Using Infura's relayer for now ...\n            uint256 fee = (tx.gasprice / 100) * 6;\n            uint256 gasPrice = tx.gasprice + fee;\n\n            // 2 call depths.\n            gasLimit = (gasLimit * 3150) / 3200;\n            uint256 gasUsed = gasLimit - gasleft() + 8000;\n\n            uint256 refundAmount = gasUsed * gasPrice;\n\n            bool success = Utils.call(\n                relayer == address(0) ? tx.origin : relayer,\n                refundAmount,\n                new bytes(0),\n                gasleft()\n            );\n\n            if (!success) revert LW__init__refundFailure();\n        }\n        // emit Setup(_owner, laserModule);\n    }\n\n    /**\n     * @notice Executes a generic transaction.\n     *         If 'gasLimit' does not match the actual gas limit of the transaction, the relayer can incur losses.\n     *         It is the relayer's responsability to make sure that they are the same,\n     *         the user does not get affected if a mistake is made.\n     *\n     * @param to                    Destination address.\n     * @param value                 Amount in WEI to transfer.\n     * @param callData              Data payload for the transaction.\n     * @param _nonce                Anti-replay number.\n     * @param maxFeePerGas          Maximum WEI the owner is willing to pay per unit of gas.\n     * @param maxPriorityFeePerGas  Miner's tip.\n     * @param gasLimit              Maximum amount of gas the owner is willing to use for this transaction.\n     * @param relayer               Address to refund for the inclusion of this transaction.\n     * @param signatures            The signature(s) of the hash of this transaction.\n     */\n    function exec(\n        address to,\n        uint256 value,\n        bytes calldata callData,\n        uint256 _nonce,\n        uint256 maxFeePerGas,\n        uint256 maxPriorityFeePerGas,\n        uint256 gasLimit,\n        address relayer,\n        bytes memory signatures\n    ) public returns (bool success) {\n        // We immediately increase the nonce to avoid replay attacks.\n        unchecked {\n            if (nonce++ != _nonce) revert LW__exec__invalidNonce();\n        }\n\n        // If the wallet is locked, further transactions cannot be executed from 'exec'.\n        if (isLocked) revert LW__exec__walletLocked();\n\n        // We get the hash of this transaction.\n        bytes32 signedHash = keccak256(\n            encodeOperation(to, value, callData, _nonce, maxFeePerGas, maxPriorityFeePerGas, gasLimit)\n        );\n\n        // We get the signer of the hash of this transaction.\n        address signer = Utils.returnSigner(signedHash, signatures, 0);\n\n        // The signer must be the owner.\n        if (signer != owner) revert LW__exec__notOwner();\n        // We call Laser master guard to verify the transaction (in bounds).\n        ILaserGuard(laserMasterGuard).verifyTransaction(\n            address(this),\n            to,\n            value,\n            callData,\n            _nonce,\n            maxFeePerGas,\n            maxPriorityFeePerGas,\n            gasLimit,\n            signatures\n        );\n        // We execute the main transaction but we keep 10_000 units of gas for the remaining operations.\n        success = Utils.call(to, value, callData, gasleft() - 10000);\n\n        // We do not revert the call if it fails, because the wallet needs to pay the relayer even in case of failure.\n        if (success) emit ExecSuccess(to, value, nonce);\n        else emit ExecFailure(to, value, nonce);\n\n        if (gasLimit > 0) {\n            // If gas limit is greater than 0, it means that the call was relayed.\n\n            // We are using Infura's relayer for now ...\n            uint256 fee = (tx.gasprice / 100) * 6;\n            uint256 gasPrice = tx.gasprice + fee;\n            gasLimit = (gasLimit * 63) / 64;\n            uint256 gasUsed = gasLimit - gasleft() + 7000;\n            uint256 refundAmount = gasUsed * gasPrice;\n            success = Utils.call(relayer == address(0) ? tx.origin : relayer, refundAmount, new bytes(0), gasleft());\n            if (!success) revert LW__exec__refundFailure();\n        }\n    }\n\n    /**\n     * @notice Executes a batch of transactions.\n     *\n     * @param transactions An array of Laser transactions.\n     */\n    function multiCall(Transaction[] calldata transactions) external {\n        uint256 transactionsLength = transactions.length;\n\n        //@todo custom errors and optimization.\n        for (uint256 i = 0; i < transactionsLength; ) {\n            Transaction calldata transaction = transactions[i];\n\n            exec(\n                transaction.to,\n                transaction.value,\n                transaction.callData,\n                transaction.nonce,\n                transaction.maxFeePerGas,\n                transaction.maxPriorityFeePerGas,\n                transaction.gasLimit,\n                transaction.relayer,\n                transaction.signatures\n            );\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /**\n     * @notice Executes a transaction from an authorized module.\n     *         If 'gasLimit' does not match the actual gas limit of the transaction, the relayer can incur losses.\n     *         It is the relayer's responsability to make sure that they are the same,\n     *         the user does not get affected if a mistake is made.\n     *\n     * @param to                    Destination address.\n     * @param value                 Amount in WEI to transfer.\n     * @param callData              Data payload for the transaction.\n     * @param maxFeePerGas          Maximum WEI the owner is willing to pay per unit of gas.\n     * @param maxPriorityFeePerGas  Miner's tip.\n     * @param gasLimit              Maximum amount of gas the owner is willing to use for this transaction.\n     * @param relayer               Address to refund for the inclusion of this transaction.\n     */\n    function execFromModule(\n        address to,\n        uint256 value,\n        bytes calldata callData,\n        uint256 maxFeePerGas,\n        uint256 maxPriorityFeePerGas,\n        uint256 gasLimit,\n        address relayer\n    ) external {\n        // We quiet compiler warnings FOR NOW.\n        (maxFeePerGas, maxPriorityFeePerGas);\n        unchecked {\n            nonce++;\n        }\n        if (laserModules[msg.sender] == address(0)) revert LW__execFromModule__unauthorizedModule();\n\n        bool success = Utils.call(to, value, callData, gasleft() - 10000);\n\n        if (!success) revert LW__execFromModule__mainCallFailed();\n\n        if (gasLimit > 0) {\n            // Using infura relayer for now ...\n            uint256 fee = (tx.gasprice / 100) * 6;\n            uint256 gasPrice = tx.gasprice + fee;\n            gasLimit = (gasLimit * 63) / 64;\n            uint256 gasUsed = gasLimit - gasleft() + 7000;\n            uint256 refundAmount = gasUsed * gasPrice;\n\n            success = Utils.call(relayer == address(0) ? tx.origin : relayer, refundAmount, new bytes(0), gasleft());\n\n            if (!success) revert LW__execFromModule__refundFailure();\n        }\n    }\n\n    /**\n     * @notice Simulates a transaction.\n     *         It needs to be called off-chain from address(0).\n     *\n     * @param to                    Destination address.\n     * @param value                 Amount in WEI to transfer.\n     * @param callData              Data payload for the transaction.\n     * @param _nonce                Anti-replay number.\n     * @param maxFeePerGas          Maximum WEI the owner is willing to pay per unit of gas.\n     * @param maxPriorityFeePerGas  Miner's tip.\n     * @param gasLimit              Maximum amount of gas the owner is willing to use for this transaction.\n     * @param relayer               Address to refund for the inclusion of this transaction.\n     * @param signatures            The signature(s) of the hash of this transaction.\n     *\n     * @return gasUsed The gas used for this transaction.\n     */\n    function simulateTransaction(\n        address to,\n        uint256 value,\n        bytes calldata callData,\n        uint256 _nonce,\n        uint256 maxFeePerGas,\n        uint256 maxPriorityFeePerGas,\n        uint256 gasLimit,\n        address relayer,\n        bytes memory signatures\n    ) external returns (uint256 gasUsed) {\n        // We immediately increase the nonce to avoid replay attacks.\n        unchecked {\n            if (nonce++ != _nonce) revert LW__SIMULATION__invalidNonce();\n        }\n\n        // If the wallet is locked, further transactions cannot be executed from 'exec'.\n        if (isLocked) revert LW__SIMULATION__walletLocked();\n\n        // We get the hash of this transaction.\n        bytes32 signedHash = keccak256(\n            encodeOperation(to, value, callData, _nonce, maxFeePerGas, maxPriorityFeePerGas, gasLimit)\n        );\n\n        // We get the signer of the hash of this transaction.\n        address signer = Utils.returnSigner(signedHash, signatures, 0);\n\n        // The signer must be the owner.\n        if (signer != owner) revert LW__SIMULATION__notOwner();\n        // We call Laser master guard to verify the transaction (in bounds).\n        ILaserGuard(laserMasterGuard).verifyTransaction(\n            address(this),\n            to,\n            value,\n            callData,\n            _nonce,\n            maxFeePerGas,\n            maxPriorityFeePerGas,\n            gasLimit,\n            signatures\n        );\n        // We execute the main transaction but we keep 10_000 units of gas for the remaining operations.\n        bool success = Utils.call(to, value, callData, gasleft() - 10000);\n\n        // We do not revert the call if it fails, because the wallet needs to pay the relayer even in case of failure.\n        if (success) emit ExecSuccess(to, value, nonce);\n        else emit ExecFailure(to, value, nonce);\n\n        if (gasLimit > 0) {\n            // If gas limit is greater than 0, it means that the call was relayed.\n\n            // We are using Infura's relayer for now ...\n            uint256 fee = (tx.gasprice / 100) * 6;\n            uint256 gasPrice = tx.gasprice + fee;\n            gasLimit = (gasLimit * 63) / 64;\n            uint256 _gasUsed = gasLimit - gasleft() + 7000;\n            uint256 refundAmount = _gasUsed * gasPrice;\n            success = Utils.call(relayer == address(0) ? tx.origin : relayer, refundAmount, new bytes(0), gasleft());\n            if (!success) revert LW__SIMULATION__refundFailure();\n        }\n\n        gasUsed = gasLimit - gasleft();\n        require(msg.sender == address(0), \"Must be called off-chain from 0 addr\");\n    }\n\n    /**\n     * @notice Locks the wallet. Once locked, only the SSR module can unlock it or recover it.\n     *\n     * @dev Can only be called by address(this).\n     */\n    function lock() external access {\n        isLocked = true;\n    }\n\n    /**\n     * @notice Unlocks the wallet. Can only be unlocked or recovered from the SSR module.\n     *\n     * @dev Can only be called by address(this).\n     */\n    function unlock() external access {\n        isLocked = false;\n    }\n\n    /**\n     * @notice Should return whether the signature provided is valid for the provided hash.\n     *\n     * @param hash      Hash of the data to be signed.\n     * @param signature Signature byte array associated with hash.\n     *\n     * MUST return the bytes4 magic value 0x1626ba7e when function passes.\n     * MUST NOT modify state (using STATICCALL for solc < 0.5, view modifier for solc > 0.5)\n     * MUST allow external calls\n     *\n     * @return Magic value if signature matches the owner's address and the wallet is not locked.\n     */\n    function isValidSignature(bytes32 hash, bytes memory signature) external view returns (bytes4) {\n        address recovered = Utils.returnSigner(hash, signature, 0);\n\n        if (recovered != owner || isLocked) revert LaserWallet__invalidSignature();\n        return EIP1271_MAGIC_VALUE;\n    }\n\n    /**\n     * @notice Returns the hash to be signed to execute a transaction.\n     */\n    function operationHash(\n        address to,\n        uint256 value,\n        bytes calldata callData,\n        uint256 _nonce,\n        uint256 maxFeePerGas,\n        uint256 maxPriorityFeePerGas,\n        uint256 gasLimit\n    ) external view returns (bytes32) {\n        return keccak256(encodeOperation(to, value, callData, _nonce, maxFeePerGas, maxPriorityFeePerGas, gasLimit));\n    }\n\n    /**\n     * @return chainId The chain id of this.\n     */\n    function getChainId() public view returns (uint256 chainId) {\n        return block.chainid;\n    }\n\n    /**\n     * @notice Domain separator for this wallet.\n     */\n    function domainSeparator() public view returns (bytes32) {\n        return keccak256(abi.encode(DOMAIN_SEPARATOR_TYPEHASH, getChainId(), address(this)));\n    }\n\n    /**\n     * @notice Encodes the transaction data.\n     */\n    function encodeOperation(\n        address to,\n        uint256 value,\n        bytes calldata callData,\n        uint256 _nonce,\n        uint256 maxFeePerGas,\n        uint256 maxPriorityFeePerGas,\n        uint256 gasLimit\n    ) internal view returns (bytes memory) {\n        bytes32 opHash = keccak256(\n            abi.encode(\n                LASER_TYPE_STRUCTURE,\n                to,\n                value,\n                keccak256(callData),\n                _nonce,\n                maxFeePerGas,\n                maxPriorityFeePerGas,\n                gasLimit\n            )\n        );\n\n        return abi.encodePacked(bytes1(0x19), bytes1(0x01), domainSeparator(), opHash);\n    }\n}\n"
    },
    "contracts/test/TestMigrate.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.15;\n\nimport \"../LaserWallet.sol\";\n\ncontract TestMigrate is LaserWallet {\n    function imNew() external pure returns (string memory) {\n        return \"New\";\n    }\n}\n"
    },
    "contracts/modules/laser-guard/LaserVault.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity 0.8.15;\n\nimport \"../../common/Utils.sol\";\nimport \"../../interfaces/IERC20.sol\";\nimport \"../../interfaces/ILaserModuleSSR.sol\";\nimport \"../../interfaces/ILaserState.sol\";\nimport \"../../interfaces/ILaserVault.sol\";\n\n/**\n * @title  LaserVault\n *\n * @author Rodrigo Herrera I.\n *\n * @notice Laser guard module that locks assets of a Laser wallet for extra security.\n *         It acts as a vault in the sense that the locked assets cannot be use unless the wallet's\n *         owner (or authorized module) orders otherwise.\n */\ncontract LaserVault is ILaserVault {\n    /*//////////////////////////////////////////////////////////////\n                          Init module \n    //////////////////////////////////////////////////////////////*/\n\n    address public immutable LASER_SMART_SOCIAL_RECOVERY;\n\n    /*//////////////////////////////////////////////////////////////\n                         ERC-20 function selectors\n    //////////////////////////////////////////////////////////////*/\n\n    bytes4 private constant ERC20_TRANSFER = bytes4(keccak256(\"transfer(address,uint256)\"));\n\n    bytes4 private constant ERC20_INCREASE_ALLOWANCE = bytes4(keccak256(\"increaseAllowance(address,uint256)\"));\n\n    /*//////////////////////////////////////////////////////////////\n                         ERC-721 function selectors\n    //////////////////////////////////////////////////////////////*/\n\n    bytes4 private constant ERC721_SAFE_TRANSFER_FROM =\n        bytes4(keccak256(\"safeTransferFrom(address,address,uint256,bytes)\"));\n\n    bytes4 private constant ERC721_SAFE_TRANSFER_FROM2 = bytes4(keccak256(\"safeTransferFrom(address,address,uint256)\"));\n\n    /*//////////////////////////////////////////////////////////////\n                         ERC-1155 function selectors\n    //////////////////////////////////////////////////////////////*/\n\n    bytes4 private constant ERC1155_SAFE_TRANSFER_FROM =\n        bytes4(keccak256(\"safeTransferFrom(address,address,uint256,uint256,bytes)\"));\n\n    bytes4 private constant ERC1155_SAFE_BATCH_TRANSFER_FROM =\n        bytes4(keccak256((\"safeBatchTransferFrom(address,address,uint256[],uint256[],bytes)\")));\n\n    /*//////////////////////////////////////////////////////////////\n                         Shared function selectors\n    //////////////////////////////////////////////////////////////*/\n\n    bytes4 private constant COMMON_APPROVE = bytes4(keccak256(\"approve(address,uint256)\"));\n\n    bytes4 private constant COMMON_TRANSFER_FROM = bytes4(keccak256(\"transferFrom(address,address,uint256)\"));\n\n    bytes4 private constant COMMON_SET_APPROVAL_FOR_ALL = bytes4(keccak256(\"setApprovalForAll(address,bool)\"));\n\n    /*//////////////////////////////////////////////////////////////\n                          ETH encoded address\n    //////////////////////////////////////////////////////////////*/\n\n    address private constant ETH = address(bytes20(bytes32(keccak256(\"ETH.ENCODED.LASER\"))));\n\n    /*//////////////////////////////////////////////////////////////\n                          Vault's storage\n    //////////////////////////////////////////////////////////////*/\n\n    // walletAddress => tokenAddress => amount.\n    mapping(address => mapping(address => uint256)) private tokensInVault;\n\n    // walletAddress => nftAddress => tokenId => boolean.\n    mapping(address => mapping(address => mapping(uint256 => bool))) private nftsInVault;\n\n    constructor(address smartSocialRecovery) {\n        //@todo Check that the smart social recovery is registred in LaserRegistry.\n        LASER_SMART_SOCIAL_RECOVERY = smartSocialRecovery;\n    }\n\n    /**\n     * @notice Verifies that the transaction doesn't spend assets from the vault.\n     *\n     * @param  wallet   The address of the wallet.\n     * @param  to       Destination address.\n     * @param  value    Amount in WEI to transfer.\n     * @param callData  Data payload for the transaction.\n     */\n    function verifyTransaction(\n        address wallet,\n        address to,\n        uint256 value,\n        bytes calldata callData,\n        uint256,\n        uint256,\n        uint256,\n        uint256,\n        bytes calldata\n    ) external view {\n        bytes4 funcSelector = bytes4(callData);\n\n        // If value is greater than 0, then it is an ETH transfer.\n        if (value > 0) {\n            verifyEth(wallet, value);\n        }\n\n        if (funcSelector == ERC20_TRANSFER) {\n            verifyERC20Transfer(wallet, to, callData);\n        }\n\n        if (funcSelector == COMMON_APPROVE) {\n            verifyCommonApprove(wallet, to, callData);\n        }\n\n        if (funcSelector == ERC20_INCREASE_ALLOWANCE) {\n            verifyERC20IncreaseAllowance(wallet, to, callData);\n        }\n    }\n\n    /**\n     * @notice Adds tokens to vault.\n     *\n     * @param  token  The address of the token.\n     * @param  amount Amount of tokens to add to the vault.\n     */\n    function addTokensToVault(address token, uint256 amount) external {\n        address wallet = msg.sender;\n\n        tokensInVault[wallet][token] += amount;\n\n        emit TokensAdded(token, amount);\n    }\n\n    /**\n     * @notice Removes tokens from vault.\n     *\n     * @param  token             The address of the token.\n     * @param  amount            Amount of tokens to remove to the vault.\n     * @param guardianSignature  Signature of one of the wallet's guardians.\n     *                           In order to take tokens out of the vault, it needs to be\n     *                           signed by the owner + a guardian.\n     */\n    function removeTokensFromVault(\n        address token,\n        uint256 amount,\n        bytes calldata guardianSignature\n    ) external {\n        address wallet = msg.sender;\n\n        // We subtract 1 from the nonce because the nonce was incremented at the\n        // beginning of the transaction.\n        uint256 walletNonce = ILaserState(wallet).nonce() - 1;\n\n        bytes32 signedHash = keccak256(abi.encodePacked(token, amount, block.chainid, wallet, walletNonce));\n\n        address signer = Utils.returnSigner(signedHash, guardianSignature, 0);\n\n        require(ILaserModuleSSR(LASER_SMART_SOCIAL_RECOVERY).isGuardian(wallet, signer), \"Invalid guardian signature\");\n\n        tokensInVault[wallet][token] -= amount;\n\n        emit TokensRemoved(token, amount);\n    }\n\n    /**\n     * @param wallet The address of the wallet.\n     * @param token  The address of the token.\n     *\n     * @return The amount of tokens that are in the vault from the provided token and wallet.\n     */\n    function getTokensInVault(address wallet, address token) external view returns (uint256) {\n        return tokensInVault[wallet][token];\n    }\n\n    /**\n     * @notice Verifies that the transfer amount is in bounds.\n     *\n     * @param wallet   The wallet address.\n     * @param value    Amount in 'WEI' to transfer.\n     */\n    function verifyEth(address wallet, uint256 value) internal view {\n        // If value is greater than 0, then  it is ETH transfer.\n        uint256 walletBalance = address(wallet).balance;\n\n        uint256 ethInVault = tokensInVault[wallet][ETH];\n\n        if (walletBalance - value < ethInVault) revert LaserVault__verifyEth__ethInVault();\n    }\n\n    /**\n     * @notice Verifies that the transfer amount is in bounds.\n     *\n     * @param wallet    The wallet address.\n     * @param to        The address to transfer the tokens to.\n     * @param callData  The calldata of the function.\n     */\n    function verifyERC20Transfer(\n        address wallet,\n        address to,\n        bytes calldata callData\n    ) internal view {\n        (, uint256 transferAmount) = abi.decode(callData[4:], (address, uint256));\n\n        uint256 _tokensInVault = tokensInVault[wallet][to];\n\n        uint256 walletTokenBalance = IERC20(to).balanceOf(wallet);\n\n        if (walletTokenBalance - transferAmount < _tokensInVault) {\n            revert LaserVault__verifyERC20Transfer__erc20InVault();\n        }\n    }\n\n    /**\n     * @notice Verifies that the spender's allowance is in bounds with the tokens in vault.\n     *\n     * @param wallet   The wallet address.\n     * @param to       The address to transfer the tokens to.\n     * @param callData The calldata of the function.\n     */\n    function verifyCommonApprove(\n        address wallet,\n        address to,\n        bytes calldata callData\n    ) internal view {\n        (address spender, uint256 amount) = abi.decode(callData[4:], (address, uint256));\n\n        // First we will check if it is ERC20.\n        uint256 _tokensInVault = tokensInVault[wallet][to];\n\n        if (_tokensInVault > 0) {\n            // Then it is definitely an ERC20.\n            uint256 walletTokenBalance = IERC20(to).balanceOf(wallet);\n\n            uint256 spenderAllowance = IERC20(to).allowance(wallet, spender);\n\n            if (walletTokenBalance - (amount + spenderAllowance) < _tokensInVault) {\n                revert LaserVault__verifyCommonApprove__erc20InVault();\n            }\n        }\n    }\n\n    /**\n     * @notice Verifies that the wallet has enough allowance to transfer the amount of tokens.\n     *\n     * @param wallet   The wallet address.\n     * @param to       The address to transfer the tokens to.\n     * @param callData The calldata of the function.\n     */\n    function verifyERC20IncreaseAllowance(\n        address wallet,\n        address to,\n        bytes calldata callData\n    ) internal view {\n        (address spender, uint256 addedValue) = abi.decode(callData[4:], (address, uint256));\n\n        uint256 _tokensInVault = tokensInVault[wallet][to];\n\n        uint256 walletTokenBalance = IERC20(to).balanceOf(wallet);\n\n        uint256 spenderCurrentAllowance = IERC20(to).allowance(spender, wallet);\n        uint256 spenderNewAllowance = spenderCurrentAllowance + addedValue;\n\n        require(walletTokenBalance - spenderNewAllowance > _tokensInVault, \"Allowance exceeds vault.\");\n    }\n}\n"
    },
    "contracts/interfaces/IERC20.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.15;\n\ninterface IERC20 {\n    function balanceOf(address) external view returns (uint256);\n\n    function allowance(address, address) external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/ILaserVault.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity 0.8.15;\n\n/**\n * @title  ILaserVault\n *\n * @author Rodrigo Herrera I.\n *\n * @notice Laser guard module that locks assets of a Laser wallet for extra security.\n *         It acts as a vault in the sense that the locked assets cannot be use unless the wallet's\n *         owner (or authorized module) orders otherwise.\n *\n * @dev    This interface has all events, errors, and external function for LaserMasterGuard.\n */\ninterface ILaserVault {\n    event TokensAdded(address indexed, uint256 indexed);\n    event TokensRemoved(address indexed, uint256 indexed);\n\n    // verifyEth() custom error.\n    error LaserVault__verifyEth__ethInVault();\n\n    // verifyERC20Transfer() custom error.\n    error LaserVault__verifyERC20Transfer__erc20InVault();\n\n    // verifyCommonApprove() custom error.\n    error LaserVault__verifyCommonApprove__erc20InVault();\n\n    /**\n     * @notice Verifies that the transaction doesn't spend assets from the vault.\n     *\n     * @param  wallet   The address of the wallet.\n     * @param  to       Destination address.\n     * @param  value    Amount in WEI to transfer.\n     * @param callData  Data payload for the transaction.\n     */\n    function verifyTransaction(\n        address wallet,\n        address to,\n        uint256 value,\n        bytes calldata callData,\n        uint256,\n        uint256,\n        uint256,\n        uint256,\n        bytes calldata\n    ) external view;\n\n    /**\n     * @notice Adds tokens to vault.\n     *\n     * @param  token  The address of the token.\n     * @param  amount Amount of tokens to add to the vault.\n     */\n    function addTokensToVault(address token, uint256 amount) external;\n\n    /**\n     * @notice Removes tokens from vault.\n     *\n     * @param  token             The address of the token.\n     * @param  amount            Amount of tokens to remove to the vault.\n     * @param guardianSignature  Signature of one of the wallet's guardians.\n     *                           In order to take tokens out of the vault, it needs to be\n     *                           signed by the owner + a guardian.\n     */\n    function removeTokensFromVault(\n        address token,\n        uint256 amount,\n        bytes calldata guardianSignature\n    ) external;\n\n    /**\n     * @param wallet The address of the wallet.\n     * @param token  The address of the token.\n     *\n     * @return The amount of tokens that are in the vault from the provided token and wallet.\n     */\n    function getTokensInVault(address wallet, address token) external view returns (uint256);\n}\n"
    },
    "contracts/test/MockUtils.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity 0.8.15;\n\nimport \"../interfaces/IEIP1271.sol\";\n\n/**\n * @title MockUtils - Mocks utils library for testing.\n */\ncontract MockUtils {\n    error Utils__returnSigner__invalidSignature();\n    error Utils__returnSigner__invalidContractSignature();\n\n    /**\n     * @dev Returns the signer of the hash.\n     * @param signedHash The hash that was signed.\n     */\n    function returnSigner(\n        bytes32 signedHash,\n        bytes memory signatures,\n        uint256 pos\n    ) public view returns (address signer) {\n        bytes32 r;\n        bytes32 s;\n        uint8 v;\n        (r, s, v) = splitSigs(signatures, pos);\n\n        if (v == 0) {\n            // If v is 0, then it is a contract signature.\n            // The address of the contract is encoded into r.\n            signer = address(uint160(uint256(r)));\n\n            // The signature(s) of the EOA's that control the target contract.\n            bytes memory contractSignature;\n\n            assembly {\n                contractSignature := add(add(signatures, s), 0x20)\n            }\n\n            if (IEIP1271(signer).isValidSignature(signedHash, contractSignature) != 0x1626ba7e) {\n                revert Utils__returnSigner__invalidContractSignature();\n            }\n        } else if (v > 30) {\n            signer = ecrecover(\n                keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", signedHash)),\n                v - 4,\n                r,\n                s\n            );\n        } else {\n            signer = ecrecover(signedHash, v, r, s);\n        }\n\n        if (signer == address(0)) revert Utils__returnSigner__invalidSignature();\n    }\n\n    /**\n     * @dev Returns the r, s and v of the signature.\n     * @param signatures Signature.\n     * @param pos Which signature to read.\n     */\n    function splitSigs(bytes memory signatures, uint256 pos)\n        public\n        pure\n        returns (\n            bytes32 r,\n            bytes32 s,\n            uint8 v\n        )\n    {\n        assembly {\n            let sigPos := mul(0x41, pos)\n            r := mload(add(signatures, add(sigPos, 0x20)))\n            s := mload(add(signatures, add(sigPos, 0x40)))\n            v := byte(0, mload(add(signatures, add(sigPos, 0x60))))\n        }\n    }\n\n    /**\n     * @dev Calls a target address, sends value and / or data payload.\n     * @param to Destination address.\n     * @param value Amount to send in ETH.\n     * @param data Data payload.\n     * @param txGas Amount of gas to forward.\n     */\n    function call(\n        address to,\n        uint256 value,\n        bytes memory data,\n        uint256 txGas\n    ) public returns (bool success) {\n        assembly {\n            // We execute a call to the target address and return a boolean (success, false).\n            success := call(txGas, to, value, add(data, 0x20), mload(data), 0, 0)\n        }\n    }\n\n    /**\n     * @dev Calculates the gas price.\n     */\n    function calculateGasPrice(uint256 maxFeePerGas) public view returns (uint256 gasPrice) {\n        return min(maxFeePerGas, tx.gasprice);\n    }\n\n    function min(uint256 a, uint256 b) public pure returns (uint256) {\n        return a < b ? a : b;\n    }\n}\n"
    },
    "contracts/helper/LaserHelper.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity 0.8.15;\n\nimport \"../interfaces/ILaserModuleSSR.sol\";\nimport \"../interfaces/ILaserState.sol\";\n\n///@title LaserHelper - Helper contract that outputs multiple results in a single call.\ncontract LaserHelper {\n    ///@dev Returns the wallet state + SSR module.\n    function getWalletState(address wallet, address SSRModule)\n        external\n        view\n        returns (\n            address owner,\n            address singleton,\n            bool isLocked,\n            address[] memory guardians,\n            address[] memory recoveryOwners,\n            uint256 nonce,\n            uint256 balance,\n            uint256 timeLock\n        )\n    {\n        ILaserState laser = ILaserState(wallet);\n        ILaserModuleSSR ssr = ILaserModuleSSR(SSRModule);\n        owner = laser.owner();\n        singleton = laser.singleton();\n        isLocked = laser.isLocked();\n        guardians = ssr.getGuardians(wallet);\n        recoveryOwners = ssr.getRecoveryOwners(wallet);\n        nonce = laser.nonce();\n        balance = address(wallet).balance;\n        timeLock = ssr.getWalletTimeLock(wallet);\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 800
    },
    "outputSelection": {
      "*": {
        "*": [
          "storageLayout",
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}