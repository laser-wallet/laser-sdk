{
  "language": "Solidity",
  "sources": {
    "contracts/access/Access.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity 0.8.15;\n\ncontract Access {\n    error Access__notAllowed();\n\n    modifier access() {\n        if (msg.sender != address(this)) revert Access__notAllowed();\n\n        _;\n    }\n}\n"
    },
    "contracts/state/LaserState.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity 0.8.15;\n\nimport \"../access/Access.sol\";\nimport \"../common/Utils.sol\";\nimport \"../interfaces/IERC165.sol\";\nimport \"../interfaces/ILaserState.sol\";\n\ncontract LaserState is ILaserState, Access {\n    address internal constant pointer = address(0x1);\n\n    address public singleton;\n\n    address public owner;\n\n    address public laserGuard;\n\n    bool public isLocked;\n\n    uint256 public nonce;\n\n    mapping(address => address) internal laserModules;\n\n    function changeOwner(address newOwner) external access {\n        owner = newOwner;\n    }\n\n    function addLaserModule(address newModule) external access {\n        laserModules[newModule] = laserModules[pointer];\n        laserModules[pointer] = newModule;\n    }\n\n    function changeLaserGuard(address newLaserGuard) external access {\n        laserGuard = newLaserGuard;\n    }\n\n    function upgradeSingleton(address _singleton) external access {\n        // if (_singleton == address(this)) revert Singleton__upgradeSingleton__incorrectAddress();\n\n        if (!IERC165(_singleton).supportsInterface(0xae029e0b)) {\n            //bytes4(keccak256(\"I_AM_LASER\")))\n            revert LaserState__upgradeSingleton__notLaser();\n        }\n\n        singleton = _singleton;\n    }\n\n    function activateWallet(\n        address _owner,\n        address laserModule,\n        bytes calldata laserModuleData\n    ) internal {\n        // If owner is not address 0, the wallet was already initialized ...\n        if (owner != address(0)) revert LaserState__initOwner__walletInitialized();\n\n        if (_owner.code.length != 0 || _owner == address(0)) revert LaserState__initOwner__addressWithCode();\n        owner = _owner;\n\n        if (laserModule != address(0)) {\n            bool success = Utils.call(laserModule, 0, laserModuleData, gasleft());\n            require(success);\n            laserModules[laserModule] = pointer;\n        }\n    }\n}\n"
    },
    "contracts/common/Utils.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity 0.8.15;\n\nimport \"../interfaces/IEIP1271.sol\";\n\n/**\n * @title Utils - Helper functions for Laser wallet and modules.\n */\nlibrary Utils {\n    error Utils__returnSigner__invalidSignature();\n    error Utils__returnSigner__invalidContractSignature();\n\n    ///@dev Returns the signer of the hash.\n    ///@param signedHash The hash that was signed.\n    function returnSigner(\n        bytes32 signedHash,\n        bytes memory signatures,\n        uint256 pos\n    ) internal view returns (address signer) {\n        bytes32 r;\n        bytes32 s;\n        uint8 v;\n        (r, s, v) = splitSigs(signatures, pos);\n\n        if (v == 0) {\n            // If v is 0, then it is a contract signature.\n            // The address of the contract is encoded into r.\n            signer = address(uint160(uint256(r)));\n\n            // The signature(s) of the EOA's that control the target contract.\n            bytes memory contractSignature;\n\n            assembly {\n                contractSignature := add(add(signatures, s), 0x20)\n            }\n\n            if (IEIP1271(signer).isValidSignature(signedHash, contractSignature) != 0x1626ba7e) {\n                revert Utils__returnSigner__invalidContractSignature();\n            }\n        } else if (v > 30) {\n            signer = ecrecover(\n                keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", signedHash)),\n                v - 4,\n                r,\n                s\n            );\n        } else {\n            signer = ecrecover(signedHash, v, r, s);\n        }\n\n        if (signer == address(0)) revert Utils__returnSigner__invalidSignature();\n    }\n\n    ///@dev Returns the r, s and v values of the signature.\n    ///@param pos Which signature to read.\n    function splitSigs(bytes memory signatures, uint256 pos)\n        internal\n        pure\n        returns (\n            bytes32 r,\n            bytes32 s,\n            uint8 v\n        )\n    {\n        assembly {\n            let sigPos := mul(0x41, pos)\n            r := mload(add(signatures, add(sigPos, 0x20)))\n            s := mload(add(signatures, add(sigPos, 0x40)))\n            v := byte(0, mload(add(signatures, add(sigPos, 0x60))))\n        }\n    }\n\n    ///@dev Calls a target address, sends value and / or data payload.\n    function call(\n        address to,\n        uint256 value,\n        bytes memory data,\n        uint256 txGas\n    ) internal returns (bool success) {\n        assembly {\n            success := call(txGas, to, value, add(data, 0x20), mload(data), 0, 0)\n        }\n    }\n\n    ///@dev Calculates the gas price for the transaction.\n    function calculateGasPrice(uint256 maxFeePerGas, uint256 maxPriorityFeePerGas) internal view returns (uint256) {\n        if (maxFeePerGas == maxPriorityFeePerGas) {\n            // Legacy mode (pre-EIP1559)\n            return min(maxFeePerGas, tx.gasprice);\n        }\n\n        // EIP-1559\n        // priority_fee_per_gas = min(transaction.max_priority_fee_per_gas, transaction.max_fee_per_gas - block.base_fee_per_gas)\n        // effective_gas_price = priority_fee_per_gas + block.base_fee_per_gas\n        uint256 priorityFeePerGas = min(maxPriorityFeePerGas, maxFeePerGas - block.basefee);\n\n        // effective_gas_price\n        return priorityFeePerGas + block.basefee;\n    }\n\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n}\n"
    },
    "contracts/interfaces/IERC165.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.15;\n\n/**\n * @title IERC165\n * @notice Support of ERC165.\n */\ninterface IERC165 {\n    /**\n     * @notice Query if a contract implements an interface\n     * @param interfaceID The interface identifier, as specified in ERC-165\n     * @dev Interface identification is specified in ERC-165. This function\n     * uses less than 30,000 gas.\n     * @return `true` if the contract implements `interfaceID` and\n     * interfaceID` is not 0xffffffff, `false` otherwise\n     */\n    function supportsInterface(bytes4 interfaceID) external view returns (bool);\n}\n"
    },
    "contracts/interfaces/ILaserState.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity 0.8.15;\n\ninterface ILaserState {\n    ///@dev upgradeSingleton() custom error.\n    error LaserState__upgradeSingleton__notLaser();\n\n    ///@dev initOwner() custom error.\n    error LaserState__initOwner__walletInitialized();\n    error LaserState__initOwner__addressWithCode();\n\n    function changeOwner(address newOwner) external;\n\n    function addLaserModule(address newModule) external;\n}\n"
    },
    "contracts/interfaces/IEIP1271.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity 0.8.15;\n\n/**\n * @title IEIP1271\n * @notice Interface to call external contracts to validate signature.\n */\ninterface IEIP1271 {\n    /**\n     * @dev Implementation of EIP 1271: https://eips.ethereum.org/EIPS/eip-1271.\n     * @param hash Hash of a message signed on behalf of address(this).\n     * @param signature Signature byte array associated with _msgHash.\n     * @return Magic value  or reverts with an error message.\n     */\n    function isValidSignature(bytes32 hash, bytes memory signature) external view returns (bytes4);\n}\n"
    },
    "contracts/proxies/LaserFactory.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity 0.8.15;\n\nimport \"../interfaces/IERC165.sol\";\nimport \"../interfaces/ILaserFactory.sol\";\n\ninterface ILaser {\n    function init(\n        address _owner,\n        uint256 maxFeePerGas,\n        uint256 maxPriorityFeePerGas,\n        uint256 gasLimit,\n        address relayer,\n        address laserModule,\n        bytes calldata laserModuleData,\n        bytes calldata ownerSignature\n    ) external;\n}\n\n///@title LaserFactory - Factory for creating new Laser proxies and helper methods.\ncontract LaserFactory is ILaserFactory {\n    address public immutable singleton;\n\n    /// @param _singleton Master copy of the proxy.\n\n    constructor(address _singleton) {\n        // Laser Wallet contract: bytes4(keccak256(\"I_AM_LASER\"))\n        if (!IERC165(_singleton).supportsInterface(0xae029e0b)) revert LaserFactory__constructor__invalidSingleton();\n        singleton = _singleton;\n    }\n\n    ///@dev Creates a new proxy with create 2, initializes the wallet and refunds the relayer (if gas limit is greater than 0).\n    ///@param maxFeePerGas Maximum amount that the user is willing to pay for a unit of gas.\n    ///@param maxPriorityFeePerGas Miner's tip.\n    ///@param gasLimit The transaction's gas limit. It needs to be the same as the actual transaction gas limit.\n    ///@param relayer Address that forwards the transaction so it abstracts away the gas costs.\n    ///@param ownerSignature The signatures of the transaction.\n    ///@notice If 'gasLimit' does not match the actual gas limit of the transaction, the relayer can incur losses.\n    ///It is the relayer's responsability to make sure that they are the same, the user does not get affected if a mistake is made.\n    ///We prefer to prioritize the user's safety (not overpay) over the relayer.\n    function deployProxyAndRefund(\n        address owner,\n        uint256 maxFeePerGas,\n        uint256 maxPriorityFeePerGas,\n        uint256 gasLimit,\n        address relayer,\n        address laserModule,\n        bytes calldata laserModuleData,\n        uint256 saltNumber,\n        bytes calldata ownerSignature\n    ) external returns (LaserProxy proxy) {\n        bytes32 salt = getSalt(owner, laserModule, laserModuleData, saltNumber);\n        proxy = createProxyWithCreate2(salt);\n\n        ILaser(address(proxy)).init(\n            owner,\n            maxFeePerGas,\n            maxPriorityFeePerGas,\n            gasLimit,\n            relayer,\n            laserModule,\n            laserModuleData,\n            ownerSignature\n        );\n\n        emit ProxyCreation(address(proxy));\n    }\n\n    ///@dev Precomputes the address of a proxy that is created through 'create2'.\n    function preComputeAddress(\n        address owner,\n        address laserModule,\n        bytes calldata laserModuleData,\n        uint256 saltNumber\n    ) external view returns (address) {\n        bytes memory creationCode = proxyCreationCode();\n        bytes memory data = abi.encodePacked(creationCode, uint256(uint160(singleton)));\n\n        bytes32 salt = getSalt(owner, laserModule, laserModuleData, saltNumber);\n        bytes32 hash = keccak256(abi.encodePacked(bytes1(0xff), address(this), salt, keccak256(data)));\n\n        return address(uint160(uint256(hash)));\n    }\n\n    ///@dev Allows to retrieve the runtime code of a deployed Proxy. This can be used to check that the expected Proxy was deployed.\n    function proxyRuntimeCode() external pure returns (bytes memory) {\n        return type(LaserProxy).runtimeCode;\n    }\n\n    ///@dev Allows to retrieve the creation code used for the Proxy deployment. With this it is easily possible to calculate predicted address.\n    function proxyCreationCode() public pure returns (bytes memory) {\n        return type(LaserProxy).creationCode;\n    }\n\n    ///@dev Allows to create new proxy contact using CREATE2 but it doesn't run the initializer.\n    ///This method is only meant as an utility to be called from other methods.\n    function createProxyWithCreate2(bytes32 salt) internal returns (LaserProxy proxy) {\n        bytes memory deploymentData = abi.encodePacked(type(LaserProxy).creationCode, uint256(uint160(singleton)));\n        assembly {\n            proxy := create2(0x0, add(0x20, deploymentData), mload(deploymentData), salt)\n        }\n        //@todo change the custom error name.\n        if (address(proxy) == address(0)) revert LaserFactory__create2Failed();\n    }\n\n    ///@dev Generates the salt for deployment.\n    function getSalt(\n        address owner,\n        address laserModule,\n        bytes calldata laserModuleData,\n        uint256 saltNumber\n    ) internal pure returns (bytes32 salt) {\n        salt = keccak256(abi.encodePacked(owner, laserModule, laserModuleData, saltNumber));\n    }\n}\n"
    },
    "contracts/interfaces/ILaserFactory.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity 0.8.15;\n\nimport \"../proxies/LaserProxy.sol\";\n\n/**\n * @title ILaserFactory.\n * @notice Has all the external functions, events and errors for ProxyFactory.sol.\n */\n\ninterface ILaserFactory {\n    event ProxyCreation(address proxy);\n\n    ///@dev constructor() custom error.\n    error LaserFactory__constructor__invalidSingleton();\n\n    ///@dev createProxyWithCreate2() custom error.\n    error LaserFactory__create2Failed();\n\n    /**\n     * @dev Creates a new proxy with create 2, initializes the wallet and refunds the relayer.\n     * @param maxFeePerGas Maximum amount that the user is willing to pay for a unit of gas.\n     * @param maxPriorityFeePerGas Miner's tip.\n     * @param gasLimit The transaction's gas limit. It needs to be the same as the actual transaction gas limit.\n     * @param relayer Address that forwards the transaction so it abstracts away the gas costs.\n     * @param ownerSignature The signatures of the transaction.\n     * @notice If 'gasLimit' does not match the actual gas limit of the transaction, the relayer can incur losses.\n     * It is the relayer's responsability to make sure that they are the same, the user does not get affected if a mistake is made.\n     * We prefer to prioritize the user's safety (not overpay) over the relayer.\n     */\n    function deployProxyAndRefund(\n        address owner,\n        uint256 maxFeePerGas,\n        uint256 maxPriorityFeePerGas,\n        uint256 gasLimit,\n        address relayer,\n        address laserModule,\n        bytes calldata laserModuleData,\n        uint256 saltNumber,\n        bytes calldata ownerSignature\n    ) external returns (LaserProxy proxy);\n\n    /**\n     * @dev Precomputes the address of a proxy that is created through 'create2'.\n     */\n    function preComputeAddress(\n        address owner,\n        address laserModule,\n        bytes calldata laserModuleData,\n        uint256 saltNumber\n    ) external view returns (address);\n\n    /**\n     * @dev Allows to retrieve the runtime code of a deployed Proxy. This can be used to check that the expected Proxy was deployed.\n     */\n    function proxyRuntimeCode() external pure returns (bytes memory);\n\n    /**\n     *  @dev Allows to retrieve the creation code used for the Proxy deployment. With this it is easily possible to calculate predicted address.\n     */\n    function proxyCreationCode() external pure returns (bytes memory);\n}\n"
    },
    "contracts/proxies/LaserProxy.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity 0.8.15;\n\n///@title LaserProxy - Proxy contract that delegates all calls to a master copy.\ncontract LaserProxy {\n    // The singleton always needs to be at storage slot 0.\n    address internal singleton;\n\n    ///@param _singleton Singleton address.\n    constructor(address _singleton) {\n        // The proxy creation is done through the LaserProxyFactory.\n        // The singleton is created at the factory's creation, so there is no need to do checks here.\n        singleton = _singleton;\n    }\n\n    ///@dev Fallback function forwards all transactions and returns all received return data.\n    fallback() external payable {\n        address _singleton = singleton;\n        assembly {\n            calldatacopy(0, 0, calldatasize())\n            let success := delegatecall(gas(), _singleton, 0, calldatasize(), 0, 0)\n            returndatacopy(0, 0, returndatasize())\n            if eq(success, 0) {\n                revert(0, returndatasize())\n            }\n            return(0, returndatasize())\n        }\n    }\n}\n"
    },
    "contracts/interfaces/ILaserModuleSSR.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity 0.8.15;\n\nimport \"./IERC165.sol\";\n\ninterface ILaserModuleSSR {\n    error SSR__onlyWallet__notWallet();\n\n    error SSR__initGuardians__underflow();\n\n    error SSR__initRecoveryOwners__underflow();\n\n    error SSR__verifyNewRecoveryOwnerOrGuardian__invalidAddress();\n\n    ///@dev removeGuardian() custom errors.\n    error SSR__removeGuardian__underflow();\n    error SSR__removeGuardian__invalidAddress();\n    error SSR__removeGuardian__incorrectPreviousGuardian();\n\n    ///@dev removeRecoveryOwner() custom errors.\n    error SSR__removeRecoveryOwner__underflow();\n    error SSR__removeRecoveryOwner__invalidAddress();\n    error SSR__removeRecoveryOwner__incorrectPreviousRecoveryOwner();\n\n    ///@dev swapGuardian() custom errors.\n    error SSR__swapGuardian__invalidPrevGuardian();\n    error SSR__swapGuardian__invalidOldGuardian();\n\n    ///@dev swapRecoveryOwner() custom errors.\n    error SSR__swapRecoveryOwner__invalidPrevRecoveryOwner();\n    error SSR__swapRecoveryOwner__invalidOldRecoveryOwner();\n\n    ///@dev Inits the module.\n    ///@notice The target wallet is the 'msg.sender'.\n    function initSSR(address[] calldata _guardians, address[] calldata _recoveryOwners) external;\n\n    ///@dev Locks the target wallet.\n    ///@param wallet The target wallet address.\n    ///@param callData Data payload.\n    ///@param maxFeePerGas Maximum WEI per uinit of gas.\n    ///@param gasLimit Maximum units of gas to spend for this transaction.\n    ///@param relayer Address to refund for the transaction inclusion.\n    ///@notice Can only be called by a recovery owner + guardian.\n    function lock(\n        address wallet,\n        bytes calldata callData,\n        uint256 maxFeePerGas,\n        uint256 maxPriorityFeePerGas,\n        uint256 gasLimit,\n        address relayer,\n        bytes memory signatures\n    ) external;\n\n    ///@dev Returns the chain id of this.\n    function getChainId() external view returns (uint256 chainId);\n}\n"
    },
    "contracts/modules/laser-modules/LaserModuleSSR.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity 0.8.15;\n\nimport \"../../common/Utils.sol\";\nimport \"../../interfaces/ILaserModuleSSR.sol\";\n\ninterface ILaser {\n    function nonce() external view returns (uint256);\n\n    function owner() external view returns (address);\n\n    function execFromModule(\n        address to,\n        uint256 value,\n        bytes calldata callData,\n        uint256 maxFeePerGas,\n        uint256 maxPriorityFeePerGas,\n        uint256 gasLimit,\n        address relayer\n    ) external;\n}\n\n///@dev Laser module implementation of Smart Social Recovery.\ncontract LaserModuleSSR is ILaserModuleSSR {\n    bytes32 private constant DOMAIN_SEPARATOR_TYPEHASH =\n        keccak256(\"EIP712Domain(uint256 chainId,address verifyingContract)\");\n\n    bytes32 private constant LASER_MODULE_SSR_TYPE_STRUCTURE =\n        keccak256(\n            \"LaserModuleSSR(address wallet,bytes callData,uint256 walletNonce,uint256 maxFeePerGas,uint256 maxPriorityFeePerGas,uint256 gasLimit\"\n        );\n\n    ///@dev pointer to create a mapping link list.\n    address internal constant pointer = address(0x1);\n\n    ///@dev timeLock keeps track of the recovery time delay. It gets set to 'block.timestamp' when 'lock' is triggered.\n    mapping(address => uint256) public timeLock;\n\n    mapping(address => uint256) internal recoveryOwnerCount;\n    mapping(address => uint256) internal guardianCount;\n\n    mapping(address => mapping(address => address)) internal recoveryOwners;\n    mapping(address => mapping(address => address)) internal guardians;\n\n    modifier onlyWallet(address wallet) {\n        if (msg.sender != wallet) revert SSR__onlyWallet__notWallet();\n\n        _;\n    }\n\n    ///@dev Inits the module.\n    ///@notice The target wallet is the 'msg.sender'.\n    function initSSR(address[] calldata _guardians, address[] calldata _recoveryOwners) external {\n        address wallet = msg.sender;\n\n        initGuardians(wallet, _guardians);\n        initRecoveryOwners(wallet, _recoveryOwners);\n    }\n\n    ///@dev Locks the target wallet.\n    ///Can only be called by the recovery owner + guardian.\n    function lock(\n        address wallet,\n        bytes calldata callData,\n        uint256 maxFeePerGas,\n        uint256 maxPriorityFeePerGas,\n        uint256 gasLimit,\n        address relayer,\n        bytes memory signatures\n    ) external {\n        uint256 walletNonce = ILaser(wallet).nonce();\n\n        bytes32 signedHash = keccak256(\n            encodeOperation(wallet, callData, walletNonce, maxFeePerGas, maxPriorityFeePerGas, gasLimit)\n        );\n\n        require(bytes4(callData) == bytes4(keccak256(\"lock()\")), \"should be the same!\");\n\n        address signer1 = Utils.returnSigner(signedHash, signatures, 0);\n        require(recoveryOwners[wallet][signer1] != address(0));\n\n        address signer2 = Utils.returnSigner(signedHash, signatures, 1);\n        require(guardians[wallet][signer2] != address(0));\n\n        timeLock[wallet] = block.timestamp;\n\n        ILaser(wallet).execFromModule(wallet, 0, callData, maxFeePerGas, maxPriorityFeePerGas, gasLimit, relayer);\n    }\n\n    /**\n     * @dev Unlocks the target wallet.\n     * @notice Can only be called with the signature of the wallet's owner + recovery owner or  owner + guardian.\n     */\n    function unlock(\n        address wallet,\n        bytes calldata callData,\n        uint256 maxFeePerGas,\n        uint256 maxPriorityFeePerGas,\n        uint256 gasLimit,\n        address relayer,\n        bytes memory signatures\n    ) external {\n        uint256 walletNonce = ILaser(wallet).nonce();\n\n        bytes32 signedHash = keccak256(\n            encodeOperation(wallet, callData, walletNonce, maxFeePerGas, maxPriorityFeePerGas, gasLimit)\n        );\n\n        require(bytes4(callData) == bytes4(keccak256(\"unlock()\")), \"should be the same!\");\n\n        address walletOwner = ILaser(wallet).owner();\n        require(walletOwner != address(0));\n\n        address signer1 = Utils.returnSigner(signedHash, signatures, 0);\n        require(signer1 == walletOwner);\n\n        address signer2 = Utils.returnSigner(signedHash, signatures, 1);\n        require(\n            guardians[wallet][signer2] != address(0) || recoveryOwners[wallet][signer2] != address(0),\n            \"nop signer2\"\n        );\n\n        timeLock[wallet] = 0;\n        ILaser(wallet).execFromModule(wallet, 0, callData, maxFeePerGas, maxPriorityFeePerGas, gasLimit, relayer);\n    }\n\n    function recover(\n        address wallet,\n        bytes calldata callData,\n        uint256 maxFeePerGas,\n        uint256 maxPriorityFeePerGas,\n        uint256 gasLimit,\n        address relayer,\n        bytes memory signatures\n    ) external {\n        uint256 walletNonce = ILaser(wallet).nonce();\n\n        bytes32 signedHash = keccak256(\n            encodeOperation(wallet, callData, walletNonce, maxFeePerGas, maxPriorityFeePerGas, gasLimit)\n        );\n\n        require(bytes4(callData) == bytes4(keccak256(\"changeOwner(address)\")), \"should be change owner.\");\n\n        address signer1 = Utils.returnSigner(signedHash, signatures, 0);\n        require(recoveryOwners[wallet][signer1] != address(0));\n\n        address signer2 = Utils.returnSigner(signedHash, signatures, 1);\n        require(guardians[wallet][signer2] != address(0), \"nop signer2\");\n\n        require(timeLock[wallet] + 1 weeks < block.timestamp, \"incorrect time\");\n        timeLock[wallet] = 0;\n        ILaser(wallet).execFromModule(wallet, 0, callData, maxFeePerGas, maxPriorityFeePerGas, gasLimit, relayer);\n    }\n\n    function addGuardian(address wallet, address newGuardian) external onlyWallet(wallet) {\n        require(wallet == msg.sender);\n        verifyNewRecoveryOwnerOrGuardian(wallet, newGuardian);\n        guardians[wallet][newGuardian] = guardians[wallet][pointer];\n        guardians[wallet][pointer] = newGuardian;\n\n        unchecked {\n            guardianCount[wallet]++;\n        }\n    }\n\n    function removeGuardian(\n        address wallet,\n        address prevGuardian,\n        address guardianToRemove\n    ) external onlyWallet(wallet) {\n        // There needs to be at least 1 guardian.\n        if (guardianCount[wallet] < 2) revert SSR__removeGuardian__underflow();\n\n        if (guardianToRemove == pointer) revert SSR__removeGuardian__invalidAddress();\n\n        if (guardians[wallet][prevGuardian] != guardianToRemove)\n            revert SSR__removeGuardian__incorrectPreviousGuardian();\n\n        guardians[wallet][prevGuardian] = guardians[wallet][guardianToRemove];\n        guardians[wallet][guardianToRemove] = address(0);\n\n        unchecked {\n            // Can't underflow, there needs to be more than 2 guardians to reach here.\n            guardianCount[wallet]--;\n        }\n    }\n\n    function swapGuardian(\n        address wallet,\n        address prevGuardian,\n        address newGuardian,\n        address oldGuardian\n    ) external onlyWallet(wallet) {\n        verifyNewRecoveryOwnerOrGuardian(wallet, newGuardian);\n\n        if (guardians[wallet][prevGuardian] != oldGuardian) revert SSR__swapGuardian__invalidPrevGuardian();\n\n        if (oldGuardian == pointer) revert SSR__swapGuardian__invalidOldGuardian();\n\n        guardians[wallet][newGuardian] = guardians[wallet][oldGuardian];\n        guardians[wallet][prevGuardian] = newGuardian;\n        guardians[wallet][oldGuardian] = address(0);\n    }\n\n    function addRecoveryOwner(address wallet, address newRecoveryOwner) external onlyWallet(wallet) {\n        verifyNewRecoveryOwnerOrGuardian(wallet, newRecoveryOwner);\n        recoveryOwners[wallet][newRecoveryOwner] = recoveryOwners[wallet][pointer];\n        recoveryOwners[wallet][pointer] = newRecoveryOwner;\n\n        unchecked {\n            recoveryOwnerCount[wallet]++;\n        }\n    }\n\n    function removeRecoveryOwner(\n        address wallet,\n        address prevRecoveryOwner,\n        address recoveryOwnerToRemove\n    ) external onlyWallet(wallet) {\n        // There needs to be at least 1 recovery owner.\n        if (recoveryOwnerCount[wallet] < 2) revert SSR__removeRecoveryOwner__underflow();\n\n        if (recoveryOwnerToRemove == pointer) revert SSR__removeRecoveryOwner__invalidAddress();\n\n        if (recoveryOwners[wallet][prevRecoveryOwner] != recoveryOwnerToRemove) {\n            revert SSR__removeRecoveryOwner__incorrectPreviousRecoveryOwner();\n        }\n\n        recoveryOwners[wallet][prevRecoveryOwner] = recoveryOwners[wallet][recoveryOwnerToRemove];\n        recoveryOwners[wallet][recoveryOwnerToRemove] = address(0);\n\n        unchecked {\n            // Can't underflow, there needs to be more than 2 guardians to reach here.\n            recoveryOwnerCount[wallet]--;\n        }\n    }\n\n    function swapRecoveryOwner(\n        address wallet,\n        address prevRecoveryOwner,\n        address newRecoveryOwner,\n        address oldRecoveryOwner\n    ) external onlyWallet(wallet) {\n        verifyNewRecoveryOwnerOrGuardian(wallet, newRecoveryOwner);\n        if (recoveryOwners[wallet][prevRecoveryOwner] != oldRecoveryOwner) {\n            revert SSR__swapRecoveryOwner__invalidPrevRecoveryOwner();\n        }\n\n        if (oldRecoveryOwner == pointer) revert SSR__swapRecoveryOwner__invalidOldRecoveryOwner();\n\n        recoveryOwners[wallet][newRecoveryOwner] = recoveryOwners[wallet][oldRecoveryOwner];\n        recoveryOwners[wallet][prevRecoveryOwner] = newRecoveryOwner;\n        recoveryOwners[wallet][oldRecoveryOwner] = address(0);\n    }\n\n    function getGuardians(address wallet) external view returns (address[] memory) {\n        address[] memory guardiansArray = new address[](guardianCount[wallet]);\n        address currentGuardian = guardians[wallet][pointer];\n\n        uint256 index;\n        while (currentGuardian != pointer) {\n            guardiansArray[index] = currentGuardian;\n            currentGuardian = guardians[wallet][currentGuardian];\n            unchecked {\n                ++index;\n            }\n        }\n        return guardiansArray;\n    }\n\n    function getRecoveryOwners(address wallet) external view returns (address[] memory) {\n        address[] memory recoveryOwnersArray = new address[](recoveryOwnerCount[wallet]);\n\n        address currentRecoveryOwner = recoveryOwners[wallet][pointer];\n\n        uint256 index;\n        while (currentRecoveryOwner != pointer) {\n            recoveryOwnersArray[index] = currentRecoveryOwner;\n            currentRecoveryOwner = recoveryOwners[wallet][currentRecoveryOwner];\n            unchecked {\n                ++index;\n            }\n        }\n        return recoveryOwnersArray;\n    }\n\n    function initGuardians(address wallet, address[] calldata _guardians) internal {\n        uint256 guardiansLength = _guardians.length;\n\n        if (guardiansLength < 1) revert SSR__initGuardians__underflow();\n\n        address currentGuardian = pointer;\n\n        for (uint256 i = 0; i < guardiansLength; ) {\n            address guardian = _guardians[i];\n\n            guardians[wallet][currentGuardian] = guardian;\n            currentGuardian = guardian;\n\n            verifyNewRecoveryOwnerOrGuardian(wallet, guardian);\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        guardians[wallet][currentGuardian] = pointer;\n        guardianCount[wallet] = guardiansLength;\n    }\n\n    ///@dev Inits the recovery owners for the target wallet.\n    ///@param wallet The target wallet address.\n    ///@param _recoveryOwners Array of the recovery owners addresses.\n    function initRecoveryOwners(address wallet, address[] calldata _recoveryOwners) internal {\n        uint256 recoveryOwnersLength = _recoveryOwners.length;\n\n        if (recoveryOwnersLength < 1) revert SSR__initRecoveryOwners__underflow();\n\n        address currentRecoveryOwner = pointer;\n\n        for (uint256 i = 0; i < recoveryOwnersLength; ) {\n            address recoveryOwner = _recoveryOwners[i];\n\n            recoveryOwners[wallet][currentRecoveryOwner] = recoveryOwner;\n            currentRecoveryOwner = recoveryOwner;\n\n            verifyNewRecoveryOwnerOrGuardian(wallet, recoveryOwner);\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        recoveryOwners[wallet][currentRecoveryOwner] = pointer;\n        recoveryOwnerCount[wallet] = recoveryOwnersLength;\n    }\n\n    function verifyNewRecoveryOwnerOrGuardian(address wallet, address toVerify) internal view {\n        address owner = ILaser(wallet).owner();\n\n        if (toVerify.code.length > 0) {\n            // If the recovery owner is a smart contract wallet, it needs to support EIP1271.\n            if (!IERC165(toVerify).supportsInterface(0x1626ba7e)) {\n                revert SSR__verifyNewRecoveryOwnerOrGuardian__invalidAddress();\n            }\n        }\n        if (\n            toVerify == address(0) ||\n            toVerify == owner ||\n            guardians[wallet][toVerify] != address(0) ||\n            recoveryOwners[wallet][toVerify] != address(0)\n        ) revert SSR__verifyNewRecoveryOwnerOrGuardian__invalidAddress();\n    }\n\n    ///@dev Returns the chain id of this.\n    function getChainId() public view returns (uint256 chainId) {\n        return block.chainid;\n    }\n\n    function domainSeparator() public view returns (bytes32) {\n        return keccak256(abi.encode(DOMAIN_SEPARATOR_TYPEHASH, getChainId(), address(this)));\n    }\n\n    function encodeOperation(\n        address wallet,\n        bytes calldata callData,\n        uint256 walletNonce,\n        uint256 maxFeePerGas,\n        uint256 maxPriorityFeePerGas,\n        uint256 gasLimit\n    ) internal view returns (bytes memory) {\n        bytes32 opHash = keccak256(\n            abi.encode(\n                LASER_MODULE_SSR_TYPE_STRUCTURE,\n                wallet,\n                keccak256(callData),\n                walletNonce,\n                maxFeePerGas,\n                maxPriorityFeePerGas,\n                gasLimit\n            )\n        );\n\n        return abi.encodePacked(bytes1(0x19), bytes1(0x01), domainSeparator(), opHash);\n    }\n\n    function operationHash(\n        address wallet,\n        bytes calldata callData,\n        uint256 walletNonce,\n        uint256 maxFeePerGas,\n        uint256 maxPriorityFeePerGas,\n        uint256 gasLimit\n    ) external view returns (bytes32) {\n        return keccak256(encodeOperation(wallet, callData, walletNonce, maxFeePerGas, maxPriorityFeePerGas, gasLimit));\n    }\n}\n"
    },
    "contracts/test/MockUtils.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity 0.8.15;\n\nimport \"../interfaces/IEIP1271.sol\";\n\n/**\n * @title MockUtils - Mocks utils library for testing.\n */\ncontract MockUtils {\n    error Utils__returnSigner__invalidSignature();\n    error Utils__returnSigner__invalidContractSignature();\n\n    /**\n     * @dev Returns the signer of the hash.\n     * @param signedHash The hash that was signed.\n     */\n    function returnSigner(\n        bytes32 signedHash,\n        bytes memory signatures,\n        uint256 pos\n    ) public view returns (address signer) {\n        bytes32 r;\n        bytes32 s;\n        uint8 v;\n        (r, s, v) = splitSigs(signatures, pos);\n\n        if (v == 0) {\n            // If v is 0, then it is a contract signature.\n            // The address of the contract is encoded into r.\n            signer = address(uint160(uint256(r)));\n\n            // The signature(s) of the EOA's that control the target contract.\n            bytes memory contractSignature;\n\n            assembly {\n                contractSignature := add(add(signatures, s), 0x20)\n            }\n\n            if (IEIP1271(signer).isValidSignature(signedHash, contractSignature) != 0x1626ba7e) {\n                revert Utils__returnSigner__invalidContractSignature();\n            }\n        } else if (v > 30) {\n            signer = ecrecover(\n                keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", signedHash)),\n                v - 4,\n                r,\n                s\n            );\n        } else {\n            signer = ecrecover(signedHash, v, r, s);\n        }\n\n        if (signer == address(0)) revert Utils__returnSigner__invalidSignature();\n    }\n\n    /**\n     * @dev Returns the r, s and v of the signature.\n     * @param signatures Signature.\n     * @param pos Which signature to read.\n     */\n    function splitSigs(bytes memory signatures, uint256 pos)\n        public\n        pure\n        returns (\n            bytes32 r,\n            bytes32 s,\n            uint8 v\n        )\n    {\n        assembly {\n            let sigPos := mul(0x41, pos)\n            r := mload(add(signatures, add(sigPos, 0x20)))\n            s := mload(add(signatures, add(sigPos, 0x40)))\n            v := byte(0, mload(add(signatures, add(sigPos, 0x60))))\n        }\n    }\n\n    /**\n     * @dev Calls a target address, sends value and / or data payload.\n     * @param to Destination address.\n     * @param value Amount to send in ETH.\n     * @param data Data payload.\n     * @param txGas Amount of gas to forward.\n     */\n    function call(\n        address to,\n        uint256 value,\n        bytes memory data,\n        uint256 txGas\n    ) public returns (bool success) {\n        assembly {\n            // We execute a call to the target address and return a boolean (success, false).\n            success := call(txGas, to, value, add(data, 0x20), mload(data), 0, 0)\n        }\n    }\n\n    /**\n     * @dev Calculates the gas price.\n     */\n    function calculateGasPrice(uint256 maxFeePerGas) public view returns (uint256 gasPrice) {\n        return min(maxFeePerGas, tx.gasprice);\n    }\n\n    function min(uint256 a, uint256 b) public pure returns (uint256) {\n        return a < b ? a : b;\n    }\n}\n"
    },
    "contracts/handlers/Handler.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.15;\n\nimport \"../interfaces/IHandler.sol\";\nimport \"../interfaces/IERC165.sol\";\n\n/**\n * @title Handler - Supports token callbacks.\n */\ncontract Handler is IHandler, IERC165 {\n    function onERC721Received(\n        address,\n        address,\n        uint256,\n        bytes calldata\n    ) external pure returns (bytes4) {\n        return 0x150b7a02;\n    }\n\n    function onERC1155Received(\n        address,\n        address,\n        uint256,\n        uint256,\n        bytes calldata\n    ) external pure returns (bytes4) {\n        return 0xf23a6e61;\n    }\n\n    function onERC1155BatchReceived(\n        address,\n        address,\n        uint256[] calldata,\n        uint256[] calldata,\n        bytes calldata\n    ) external pure returns (bytes4 result) {\n        return 0xbc197c81;\n    }\n\n    function tokensReceived(\n        address,\n        address,\n        address,\n        uint256,\n        bytes calldata,\n        bytes calldata\n    ) external pure {}\n\n    function supportsInterface(bytes4 _interfaceId) external pure returns (bool) {\n        return\n            _interfaceId == 0x01ffc9a7 || // ERC165 interface ID for ERC165\n            _interfaceId == 0x1626ba7e || // EIP 1271\n            _interfaceId == 0xd9b67a26 || // ERC165 interface ID for ERC1155\n            _interfaceId == 0x4e2312e0 || // ERC-1155 `ERC1155TokenReceiver` support (i.e. `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\")) ^bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))`).\n            _interfaceId == 0xae029e0b || // Laser Wallet contract: bytes4(keccak256(\"I_AM_LASER\"))\n            _interfaceId == 0x150b7a02; // ERC721 onErc721Received\n    }\n}\n"
    },
    "contracts/interfaces/IHandler.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity 0.8.15;\n\n/**\n * @title IHandler\n * @notice Has all the external functions for Handler.sol.\n */\ninterface IHandler {\n    function onERC721Received(\n        address,\n        address,\n        uint256,\n        bytes calldata\n    ) external pure returns (bytes4);\n\n    function onERC1155Received(\n        address,\n        address,\n        uint256,\n        uint256,\n        bytes calldata\n    ) external pure returns (bytes4 result);\n\n    function onERC1155BatchReceived(\n        address,\n        address,\n        uint256[] calldata,\n        uint256[] calldata,\n        bytes calldata\n    ) external pure returns (bytes4 result);\n\n    function tokensReceived(\n        address,\n        address,\n        address,\n        uint256,\n        bytes calldata,\n        bytes calldata\n    ) external pure;\n}\n"
    },
    "contracts/LaserWallet.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity 0.8.15;\n\nimport \"./handlers/Handler.sol\";\nimport \"./interfaces/ILaserWallet.sol\";\nimport \"./state/LaserState.sol\";\n\ninterface ILaserGuard {\n    function checkTransaction(address to) external;\n}\n\n///@title LaserWallet - Modular EVM based smart contract wallet.\n///@author Rodrigo Herrera I.\ncontract LaserWallet is ILaserWallet, LaserState, Handler {\n    string public constant VERSION = \"1.0.0\";\n\n    bytes4 private constant EIP1271_MAGIC_VALUE = bytes4(keccak256(\"isValidSignature(bytes32,bytes)\"));\n\n    bytes32 private constant DOMAIN_SEPARATOR_TYPEHASH =\n        keccak256(\"EIP712Domain(uint256 chainId,address verifyingContract)\");\n\n    bytes32 private constant LASER_TYPE_STRUCTURE =\n        keccak256(\n            \"LaserOperation(address to,uint256 value,bytes callData,uint256 nonce,uint256 maxFeePerGas,uint256 maxPriorityFeePerGas,uint256 gasLimit)\"\n        );\n\n    constructor() {\n        owner = address(this);\n    }\n\n    receive() external payable {}\n\n    ///@dev Setup function, sets initial storage of the wallet.\n    ///@notice It can't be called after initialization.\n    function init(\n        address _owner,\n        uint256 maxFeePerGas,\n        uint256 maxPriorityFeePerGas,\n        uint256 gasLimit,\n        address relayer,\n        address laserModule,\n        bytes calldata laserModuleData,\n        bytes calldata ownerSignature\n    ) external {\n        activateWallet(_owner, laserModule, laserModuleData);\n\n        bytes32 signedHash = keccak256(abi.encodePacked(maxFeePerGas, maxPriorityFeePerGas, gasLimit, block.chainid));\n\n        address signer = Utils.returnSigner(signedHash, ownerSignature, 0);\n\n        if (signer != _owner) revert LW__init__notOwner();\n\n        if (gasLimit > 0) {\n            // Using infura relayer for now ...\n            uint256 fee = (tx.gasprice / 100) * 6;\n            uint256 gasPrice = tx.gasprice + fee;\n\n            gasLimit = (gasLimit * 3150) / 3200;\n            uint256 gasUsed = gasLimit - gasleft() + 8000;\n\n            uint256 refundAmount = gasUsed * gasPrice;\n\n            bool success = Utils.call(\n                relayer == address(0) ? tx.origin : relayer,\n                refundAmount,\n                new bytes(0),\n                gasleft()\n            );\n\n            if (!success) revert LW__init__refundFailure();\n        }\n        // emit Setup(_owner, laserModule);\n    }\n\n    /**\n     * @dev Executes a generic transaction. It does not support 'delegatecall' for security reasons.\n     * @param to Destination address.\n     * @param value Amount to send.\n     * @param callData Data payload for the transaction.\n     * @param ownerSignature The signatures of the transaction.\n     * @notice If 'gasLimit' does not match the actual gas limit of the transaction, the relayer can incur losses.\n     * It is the relayer's responsability to make sure that they are the same, the user does not get affected if a mistake is made.\n     * We prefer to prioritize the user's safety (not overpay) over the relayer.\n     */\n    function exec(\n        address to,\n        uint256 value,\n        bytes calldata callData,\n        uint256 _nonce,\n        uint256 maxFeePerGas,\n        uint256 maxPriorityFeePerGas,\n        uint256 gasLimit,\n        address relayer,\n        bytes calldata ownerSignature\n    ) external {\n        // We immediately increase the nonce to avoid replay attacks.\n        unchecked {\n            if (nonce++ != _nonce) revert LW__exec__invalidNonce();\n        }\n\n        if (isLocked) revert LW__exec__walletLocked();\n\n        bytes32 signedHash = keccak256(\n            encodeOperation(to, value, callData, _nonce, maxFeePerGas, maxPriorityFeePerGas, gasLimit)\n        );\n\n        address signer = Utils.returnSigner(signedHash, ownerSignature, 0);\n\n        if (signer != owner) revert LW__exec__notOwner();\n\n        bool success = Utils.call(to, value, callData, gasleft() - 10000);\n\n        // We do not revert the call if it fails, because the wallet needs to pay the relayer even in case of failure.\n        if (success) emit ExecSuccess(to, value, nonce);\n        else emit ExecFailure(to, value, nonce);\n\n        if (laserGuard != address(0)) {\n            ILaserGuard(laserGuard).checkTransaction(to);\n        }\n\n        // Using infura relayer for now ...\n        uint256 fee = (tx.gasprice / 100) * 6;\n        uint256 gasPrice = tx.gasprice + fee;\n        uint256 gasUsed = gasLimit - gasleft() + 7000;\n        uint256 refundAmount = gasUsed * gasPrice;\n\n        success = Utils.call(relayer == address(0) ? tx.origin : relayer, refundAmount, new bytes(0), gasleft());\n\n        if (!success) revert LW__exec__refundFailure();\n    }\n\n    ///@dev Allows to execute a transaction from an authorized module.\n    function execFromModule(\n        address to,\n        uint256 value,\n        bytes calldata callData,\n        uint256 maxFeePerGas,\n        uint256 maxPriorityFeePerGas,\n        uint256 gasLimit,\n        address relayer\n    ) external {\n        unchecked {\n            nonce++;\n        }\n        ///@todo custom errors instead of require statement.\n        require(laserModules[msg.sender] != address(0), \"nop module\");\n\n        bool success = Utils.call(to, value, callData, gasleft() - 10000);\n\n        require(success, \"main call failed\");\n\n        if (gasLimit > 0) {\n            // Using infura relayer for now ...\n            uint256 fee = (tx.gasprice / 100) * 6;\n            uint256 gasPrice = tx.gasprice + fee;\n            gasLimit = (gasLimit * 63) / 64;\n            uint256 gasUsed = gasLimit - gasleft() + 7000;\n            uint256 refundAmount = gasUsed * gasPrice;\n\n            success = Utils.call(relayer == address(0) ? tx.origin : relayer, refundAmount, new bytes(0), gasleft());\n\n            require(success, \"refund failed\");\n        }\n    }\n\n    ///@dev Locks the wallet. Once locked, only the SSR module can unlock it or recover it.\n    function lock() external access {\n        isLocked = true;\n    }\n\n    ///@dev Unlocks the wallet. Can only be unlocked or recovered from the SSR module.\n    function unlock() external access {\n        isLocked = false;\n    }\n\n    ///@dev Implementation of EIP 1271: https://eips.ethereum.org/EIPS/eip-1271.\n    ///@return Magic value  or reverts with an error message.\n    function isValidSignature(bytes32 hash, bytes memory signature) external view returns (bytes4) {\n        address recovered = Utils.returnSigner(hash, signature, 0);\n\n        // The guardians and recovery owners should not be able to sign transactions that are out of scope from this wallet.\n        // Only the owner should be able to sign external data.\n        if (recovered != owner || isLocked) revert LaserWallet__invalidSignature();\n        return EIP1271_MAGIC_VALUE;\n    }\n\n    function getChainId() public view returns (uint256 chainId) {\n        return block.chainid;\n    }\n\n    function domainSeparator() public view returns (bytes32) {\n        return keccak256(abi.encode(DOMAIN_SEPARATOR_TYPEHASH, getChainId(), address(this)));\n    }\n\n    function encodeOperation(\n        address to,\n        uint256 value,\n        bytes calldata callData,\n        uint256 _nonce,\n        uint256 maxFeePerGas,\n        uint256 maxPriorityFeePerGas,\n        uint256 gasLimit\n    ) internal view returns (bytes memory) {\n        bytes32 opHash = keccak256(\n            abi.encode(\n                LASER_TYPE_STRUCTURE,\n                to,\n                value,\n                keccak256(callData),\n                _nonce,\n                maxFeePerGas,\n                maxPriorityFeePerGas,\n                gasLimit\n            )\n        );\n\n        return abi.encodePacked(bytes1(0x19), bytes1(0x01), domainSeparator(), opHash);\n    }\n\n    function operationHash(\n        address to,\n        uint256 value,\n        bytes calldata callData,\n        uint256 _nonce,\n        uint256 maxFeePerGas,\n        uint256 maxPriorityFeePerGas,\n        uint256 gasLimit\n    ) external view returns (bytes32) {\n        return keccak256(encodeOperation(to, value, callData, _nonce, maxFeePerGas, maxPriorityFeePerGas, gasLimit));\n    }\n}\n"
    },
    "contracts/interfaces/ILaserWallet.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.15;\n\n/**\n * @title ILaserWallet\n * @author Rodrigo Herrera I.\n * @notice Has all the external functions, structs, events and errors for LaserWallet.sol.\n */\ninterface ILaserWallet {\n    event Received(address indexed sender, uint256 amount);\n    event Setup(address owner, address laserModule);\n    event ExecSuccess(address to, uint256 value, uint256 nonce);\n    event ExecFailure(address to, uint256 value, uint256 nonce);\n\n    ///@dev init() custom error.\n    error LW__init__notOwner();\n    error LW__init__refundFailure();\n\n    ///@dev exec() custom errors.\n    error LW__exec__invalidNonce();\n    error LW__exec__walletLocked();\n    error LW__exec__notOwner();\n    error LW__exec__refundFailure();\n\n    ///@dev isValidSignature() Laser custom error.\n    error LaserWallet__invalidSignature();\n\n    /**\n     * @dev Setup function, sets initial storage of the wallet.\n     * @param _owner The owner of the wallet.\n     * @param maxFeePerGas The maximum amount of WEI the user is willing to pay per unit of gas.\n     * @param maxPriorityFeePerGas Miner's tip.\n     * @param gasLimit Maximum units of gas the user is willing to use for the transaction.\n     * @param relayer Address of the relayer to pay back for the transaction inclusion.\n     * @param laserModule Authorized Laser module that can execute transactions for this wallet.\n     * @param ownerSignature The signature of the owner to make sure that it approved the transaction.\n     * @notice It can't be called after initialization.\n     */\n    function init(\n        address _owner,\n        uint256 maxFeePerGas,\n        uint256 maxPriorityFeePerGas,\n        uint256 gasLimit,\n        address relayer,\n        address laserModule,\n        bytes calldata laserGuardData,\n        bytes calldata ownerSignature\n    ) external;\n\n    /**\n     * @dev Executes a generic transaction. It does not support 'delegatecall' for security reasons.\n     * @param to Destination address.\n     * @param value Amount to send.\n     * @param callData Data payload for the transaction.\n     * @param _nonce Unsigned integer to avoid replay attacks. It needs to match the current wallet's nonce.\n     * @param maxFeePerGas Maximum amount that the user is willing to pay for a unit of gas.\n     * @param maxPriorityFeePerGas Miner's tip.\n     * @param gasLimit The transaction's gas limit. It needs to be the same as the actual transaction gas limit.\n     * @param ownerSignature The signatures of the transaction.\n     * @notice If 'gasLimit' does not match the actual gas limit of the transaction, the relayer can incur losses.\n     * It is the relayer's responsability to make sure that they are the same, the user does not get affected if a mistake is made.\n     * We prefer to prioritize the user's safety (not overpay) over the relayer.\n     */\n    function exec(\n        address to,\n        uint256 value,\n        bytes calldata callData,\n        uint256 _nonce,\n        uint256 maxFeePerGas,\n        uint256 maxPriorityFeePerGas,\n        uint256 gasLimit,\n        address relayer,\n        bytes calldata ownerSignature\n    ) external;\n\n    /**\n     * @dev Implementation of EIP 1271: https://eips.ethereum.org/EIPS/eip-1271.\n     * @param hash Hash of a message signed on behalf of address(this).\n     * @param signature Signature byte array associated with _msgHash.\n     * @return Magic value  or reverts with an error message.\n     */\n    function isValidSignature(bytes32 hash, bytes memory signature) external returns (bytes4);\n}\n"
    },
    "contracts/test/TestMigrate.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.15;\n\nimport \"../LaserWallet.sol\";\n\ncontract TestMigrate is LaserWallet {\n    function imNew() external pure returns (string memory) {\n        return \"New\";\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 800
    },
    "outputSelection": {
      "*": {
        "*": [
          "storageLayout",
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}